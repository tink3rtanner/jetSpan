<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>L'Hostis Shrivelled Map - 3D</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
    .info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px 20px;
      border-radius: 8px;
      max-width: 320px;
    }
    .info h1 {
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 8px;
    }
    .info p {
      font-size: 0.85rem;
      color: #aaa;
      line-height: 1.5;
    }
    .controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px 20px;
      border-radius: 8px;
    }
    .controls label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }
    .controls input[type="range"] {
      width: 200px;
    }
    .legend {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px 20px;
      border-radius: 8px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }
    .legend-color {
      width: 20px;
      height: 12px;
      margin-right: 10px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="info">
    <h1>L'Hostis Shrivelled Map</h1>
    <p>3D time-space visualization of the USA. Airports sit at peaks (fast air travel keeps them "high"). The terrain sags into valleys between cities, representing slow ground travel time.</p>
  </div>

  <div class="controls">
    <label>
      Shrivel Intensity: <span id="intensityVal">1.0</span>
      <br>
      <input type="range" id="intensity" min="0" max="2" step="0.1" value="1">
    </label>
    <label>
      <input type="checkbox" id="showAirRoutes" checked> Show Air Routes
    </label>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-color" style="background: #e74c3c;"></div>
      Major Airports (peaks)
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #f4d03f;"></div>
      High elevation (near airports)
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #2ecc71;"></div>
      Medium elevation
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #3498db;"></div>
      Low elevation (valleys)
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #9b59b6;"></div>
      Air routes
    </div>
  </div>

  <script>
    // Major US airports with coordinates
    const airports = [
      { code: "SEA", name: "Seattle", lng: -122.3, lat: 47.4 },
      { code: "SFO", name: "San Francisco", lng: -122.4, lat: 37.6 },
      { code: "LAX", name: "Los Angeles", lng: -118.4, lat: 33.9 },
      { code: "PHX", name: "Phoenix", lng: -112.0, lat: 33.4 },
      { code: "DEN", name: "Denver", lng: -104.7, lat: 39.9 },
      { code: "DFW", name: "Dallas", lng: -97.0, lat: 32.9 },
      { code: "MSP", name: "Minneapolis", lng: -93.2, lat: 44.9 },
      { code: "ORD", name: "Chicago", lng: -87.9, lat: 41.9 },
      { code: "ATL", name: "Atlanta", lng: -84.4, lat: 33.6 },
      { code: "MIA", name: "Miami", lng: -80.3, lat: 25.8 },
      { code: "CLT", name: "Charlotte", lng: -80.9, lat: 35.2 },
      { code: "DCA", name: "Washington", lng: -77.0, lat: 38.9 },
      { code: "JFK", name: "New York", lng: -73.8, lat: 40.6 },
      { code: "BOS", name: "Boston", lng: -71.0, lat: 42.4 },
    ];

    // Air routes between airports
    const airRoutes = [
      ["SEA", "SFO"], ["SFO", "LAX"], ["LAX", "PHX"], ["PHX", "DEN"],
      ["DEN", "DFW"], ["DFW", "ATL"], ["ATL", "MIA"], ["ATL", "CLT"],
      ["CLT", "DCA"], ["DCA", "JFK"], ["JFK", "BOS"], ["ORD", "JFK"],
      ["ORD", "ATL"], ["MSP", "ORD"], ["DEN", "ORD"], ["SEA", "MSP"],
      ["LAX", "DFW"], ["SFO", "ORD"], ["LAX", "JFK"], ["SEA", "JFK"],
      ["DEN", "JFK"], ["LAX", "ATL"], ["SFO", "DFW"], ["PHX", "ORD"],
    ];

    // Scene setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 80, 100);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    scene.add(directionalLight);

    // Convert lat/lng to 3D coordinates
    function geoTo3D(lng, lat) {
      const x = (lng + 97) * 1.5;  // Center around US
      const z = (40 - lat) * 1.5;
      return { x, z };
    }

    // Calculate elevation at a point based on distance to airports
    let shrivelIntensity = 1.0;

    function getElevation(x, z) {
      let minDist = Infinity;

      airports.forEach(airport => {
        const pos = geoTo3D(airport.lng, airport.lat);
        const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
        minDist = Math.min(minDist, dist);
      });

      // Elevation is high near airports, low (negative) far from them
      // This creates peaks at airports and valleys between
      const baseElevation = -15 * shrivelIntensity;
      const peakInfluence = Math.max(0, 20 - minDist) * shrivelIntensity;

      return baseElevation + peakInfluence * 1.5;
    }

    // US outline points for bounded terrain
    const usOutlineGeo = [
      [-124.7, 48.4], [-124.5, 46], [-124, 43], [-124, 41], [-120, 39], [-120, 35],
      [-117.5, 33], [-114.6, 32.7], [-111.1, 31.3], [-108.2, 31.3],
      [-106.5, 31.8], [-104.5, 29.5], [-103, 29], [-100, 28], [-97.4, 26],
      [-97.1, 27.8], [-97, 29], [-94.5, 29.5], [-91.8, 29.5], [-89.6, 29.2],
      [-89, 30.2], [-88, 30.2], [-86.5, 30.4], [-85, 29.7], [-83, 29],
      [-82.5, 27.5], [-81.5, 25.5], [-80.2, 25.2], [-80.1, 27], [-80.5, 29],
      [-81, 31], [-79.5, 33], [-78, 34], [-76, 35], [-75.5, 37], [-75, 38],
      [-74, 39], [-74, 40.5], [-73, 41], [-71, 41.5], [-70, 42],
      [-70, 43.5], [-68, 44.5], [-67, 45], [-67, 47], [-68, 47.5],
      [-70, 46], [-72, 45], [-75, 45], [-77, 44], [-79, 43.5],
      [-82, 42], [-82.5, 44], [-82.5, 46], [-84, 46.5],
      [-85, 47], [-88, 48.2], [-89, 48], [-92, 48.5], [-94.5, 49],
      [-97, 49], [-100, 49], [-104, 49], [-110, 49], [-116, 49],
      [-117, 49], [-122.5, 49], [-124.5, 48.5], [-124.7, 48.4]
    ];

    // Create terrain mesh
    let terrainMesh;
    let terrainEdge;
    let airRouteMeshes = [];
    let airportMarkers = [];
    let airportLabels = [];

    // Point-in-polygon test
    function pointInUSA(x, z) {
      const poly = usOutlineGeo.map(([lng, lat]) => {
        const p = geoTo3D(lng, lat);
        return [p.x, p.z];
      });

      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i][0], zi = poly[i][1];
        const xj = poly[j][0], zj = poly[j][1];

        if (((zi > z) !== (zj > z)) && (x < (xj - xi) * (z - zi) / (zj - zi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    function createTerrain() {
      // Remove old terrain if exists
      if (terrainMesh) {
        scene.remove(terrainMesh);
        terrainMesh.geometry.dispose();
        terrainMesh.material.dispose();
      }
      if (terrainEdge) {
        scene.remove(terrainEdge);
        terrainEdge.geometry.dispose();
        terrainEdge.material.dispose();
      }

      // Create points array: boundary + interior grid
      const points2D = [];

      // Add boundary points
      usOutlineGeo.forEach(([lng, lat]) => {
        const pos = geoTo3D(lng, lat);
        points2D.push([pos.x, pos.z]);
      });

      // Add interior grid points (only those inside US)
      const gridStep = 2.5;
      for (let x = -42; x <= 42; x += gridStep) {
        for (let z = -18; z <= 18; z += gridStep) {
          if (pointInUSA(x, z)) {
            points2D.push([x, z]);
          }
        }
      }

      // Add airport positions for sharper peaks
      airports.forEach(airport => {
        const pos = geoTo3D(airport.lng, airport.lat);
        points2D.push([pos.x, pos.z]);
      });

      // Flatten for Delaunator
      const coords = points2D.flat();

      // Triangulate
      const delaunay = Delaunator.from(points2D);

      // Build geometry
      const vertices = [];
      const colors = [];
      const indices = [];

      // Add all vertices with elevation and color
      points2D.forEach(([x, z]) => {
        const elev = getElevation(x, z);
        vertices.push(x, elev, z);

        const normalizedElev = (elev + 20) / 45;
        let r, g, b;
        if (normalizedElev > 0.75) { r = 1.0; g = 0.85; b = 0.15; }
        else if (normalizedElev > 0.55) { r = 0.75; g = 0.85; b = 0.2; }
        else if (normalizedElev > 0.4) { r = 0.35; g = 0.75; b = 0.35; }
        else if (normalizedElev > 0.25) { r = 0.2; g = 0.5; b = 0.55; }
        else { r = 0.15; g = 0.3; b = 0.55; }
        colors.push(r, g, b);
      });

      // Filter triangles to only include those with centroid inside US
      for (let i = 0; i < delaunay.triangles.length; i += 3) {
        const i0 = delaunay.triangles[i];
        const i1 = delaunay.triangles[i + 1];
        const i2 = delaunay.triangles[i + 2];

        // Calculate centroid
        const cx = (points2D[i0][0] + points2D[i1][0] + points2D[i2][0]) / 3;
        const cz = (points2D[i0][1] + points2D[i1][1] + points2D[i2][1]) / 3;

        // Only include if centroid is inside US
        if (pointInUSA(cx, cz)) {
          indices.push(i0, i1, i2);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const material = new THREE.MeshLambertMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
      });

      terrainMesh = new THREE.Mesh(geometry, material);
      scene.add(terrainMesh);

      // Create white edge outline that follows the terrain elevation
      const edgePoints = usOutlineGeo.map(([lng, lat]) => {
        const pos = geoTo3D(lng, lat);
        const elev = getElevation(pos.x, pos.z);
        return new THREE.Vector3(pos.x, elev + 0.5, pos.z);
      });

      const edgeGeometry = new THREE.BufferGeometry().setFromPoints(edgePoints);
      const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });

      terrainEdge = new THREE.Line(edgeGeometry, edgeMaterial);
      scene.add(terrainEdge);
    }

    // Create airport markers
    function createAirportMarkers() {
      // Remove old markers
      airportMarkers.forEach(m => {
        scene.remove(m);
        m.geometry.dispose();
        m.material.dispose();
      });
      airportMarkers = [];

      const markerGeometry = new THREE.SphereGeometry(1.2, 16, 16);
      const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xe74c3c });

      airports.forEach(airport => {
        const pos = geoTo3D(airport.lng, airport.lat);
        const elevation = getElevation(pos.x, pos.z);

        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.set(pos.x, elevation + 2, pos.z);
        scene.add(marker);
        airportMarkers.push(marker);
      });
    }

    // Create air routes
    function createAirRoutes() {
      // Remove old routes
      airRouteMeshes.forEach(m => {
        scene.remove(m);
        m.geometry.dispose();
        m.material.dispose();
      });
      airRouteMeshes = [];

      if (!document.getElementById('showAirRoutes').checked) return;

      const routeMaterial = new THREE.LineBasicMaterial({
        color: 0x9b59b6,
        linewidth: 2,
        transparent: true,
        opacity: 0.7
      });

      airRoutes.forEach(([from, to]) => {
        const a1 = airports.find(a => a.code === from);
        const a2 = airports.find(a => a.code === to);
        if (!a1 || !a2) return;

        const pos1 = geoTo3D(a1.lng, a1.lat);
        const pos2 = geoTo3D(a2.lng, a2.lat);

        const elev1 = getElevation(pos1.x, pos1.z) + 3;
        const elev2 = getElevation(pos2.x, pos2.z) + 3;

        // Create curved path above terrain
        const points = [];
        const segments = 20;
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = pos1.x + (pos2.x - pos1.x) * t;
          const z = pos1.z + (pos2.z - pos1.z) * t;

          // Arc up in the middle
          const arc = Math.sin(t * Math.PI) * 8;
          const baseElev = elev1 + (elev2 - elev1) * t;
          const y = baseElev + arc;

          points.push(new THREE.Vector3(x, y, z));
        }

        const routeGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const route = new THREE.Line(routeGeometry, routeMaterial);
        scene.add(route);
        airRouteMeshes.push(route);
      });
    }

    // Create airport labels only (no base map)
    function createUSOutline() {
      // Just add airport labels
      airports.forEach(airport => {
        const pos = geoTo3D(airport.lng, airport.lat);
        const elevation = getElevation(pos.x, pos.z);

        // Airport label sprite
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(airport.code, 64, 45);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.set(pos.x, elevation + 4, pos.z);
        sprite.scale.set(7, 3.5, 1);
        scene.add(sprite);
      });
    }

    // Initialize
    createTerrain();
    createAirportMarkers();
    createAirRoutes();
    createUSOutline();

    // Controls
    document.getElementById('intensity').addEventListener('input', (e) => {
      shrivelIntensity = parseFloat(e.target.value);
      document.getElementById('intensityVal').textContent = shrivelIntensity.toFixed(1);
      createTerrain();
      createAirportMarkers();
      createAirRoutes();
    });

    document.getElementById('showAirRoutes').addEventListener('change', () => {
      createAirRoutes();
    });

    // Mouse controls for rotation
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraAngle = { theta: 0, phi: Math.PI / 4 };
    let cameraDistance = 120;

    container.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('mouseup', () => {
      isDragging = false;
    });

    container.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      cameraAngle.theta -= deltaX * 0.005;
      cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi - deltaY * 0.005));

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('wheel', (e) => {
      cameraDistance = Math.max(50, Math.min(200, cameraDistance + e.deltaY * 0.1));
      e.preventDefault();
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update camera position based on angles
      camera.position.x = cameraDistance * Math.sin(cameraAngle.theta) * Math.cos(cameraAngle.phi);
      camera.position.y = cameraDistance * Math.sin(cameraAngle.phi);
      camera.position.z = cameraDistance * Math.cos(cameraAngle.theta) * Math.cos(cameraAngle.phi);
      camera.lookAt(0, -5, 0);

      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
