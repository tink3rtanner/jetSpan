<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flight Isochrone Map</title>

  <!-- MapLibre GL JS v5+ for globe support -->
  <script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css" rel="stylesheet" />

  <!-- H3 for hexagonal grid -->
  <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #fff;
    }

    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Title panel (top left) */
    .title-panel {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 14px 18px;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .title-panel h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .title-panel .subtitle {
      font-size: 12px;
      color: #888;
    }

    /* Info button (top right) */
    .info-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      color: #888;
      font-size: 18px;
      cursor: pointer;
      z-index: 101;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, color 0.2s;
      padding: 0;
      line-height: 1;
    }

    .info-btn:hover,
    .info-btn.active {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    /* Info panel (slides down from top right) */
    .info-panel {
      position: absolute;
      top: 60px;
      right: 16px;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      min-width: 240px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
    }

    .info-panel.visible {
      display: block;
    }

    .info-section {
      margin-bottom: 16px;
    }

    .info-section:last-child {
      margin-bottom: 0;
    }

    .info-section-label {
      font-size: 11px;
      font-weight: 500;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .info-stats {
      display: flex;
      gap: 20px;
    }

    .toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .toggle-row:last-child {
      border-bottom: none;
    }

    .toggle-row span {
      font-size: 14px;
    }

    .toggle-switch {
      position: relative;
      width: 40px;
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 22px;
      transition: 0.3s;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      border-radius: 50%;
      transition: 0.3s;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: #22c55e;
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(18px);
    }

    .slider-row {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .slider-row:last-child {
      border-bottom: none;
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .slider-value {
      font-variant-numeric: tabular-nums;
      opacity: 0.7;
    }

    .slider-row input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
    }

    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }


    /* Legend */
    .legend {
      position: absolute;
      bottom: 32px;
      left: 16px;
      background: rgba(10, 10, 10, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .legend h3 {
      font-size: 12px;
      font-weight: 500;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
      font-size: 13px;
    }

    .legend-item:last-child {
      margin-bottom: 0;
    }

    .legend-color {
      width: 24px;
      height: 16px;
      border-radius: 4px;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      bottom: 32px;
      right: 16px;
      background: rgba(10, 10, 10, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      z-index: 100;
      min-width: 280px;
      max-width: 320px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
    }

    .tooltip.visible {
      display: block;
    }

    .tooltip-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .tooltip-location {
      font-size: 16px;
      font-weight: 600;
      flex: 1;
      min-width: 0;
    }

    .tooltip-time {
      font-size: 20px;
      font-weight: 700;
      color: #22c55e;
      white-space: nowrap;
      margin-left: 12px;
      flex-shrink: 0;
    }

    .tooltip-breakdown {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 12px;
    }

    .breakdown-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      font-size: 13px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .breakdown-row:last-child {
      border-bottom: none;
    }

    .breakdown-row .label {
      color: #888;
    }

    .breakdown-row .value {
      font-weight: 500;
    }

    .breakdown-row.route {
      color: #666;
      font-size: 11px;
      padding: 4px 0;
    }

    /* Loading overlay */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 10, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .loading-overlay.hidden {
      display: none;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: #22c55e;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 16px;
      font-size: 14px;
      color: #888;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 600;
    }

    .stat-label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Title (top left) -->
  <div class="title-panel">
    <h1>Flight Isochrone Map</h1>
    <p class="subtitle">Multimodal travel times from Bristol, UK</p>
  </div>

  <!-- Info toggle button (top right) -->
  <button class="info-btn" id="info-btn" onclick="toggleInfoPanel()">ⓘ</button>

  <!-- Info panel (hidden by default) -->
  <div class="info-panel" id="info-panel">
    <div class="info-section">
      <div class="info-section-label">Stats</div>
      <div class="info-stats">
        <div class="stat">
          <div class="stat-value" id="stat-cells">0</div>
          <div class="stat-label">Cells</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-zoom">0</div>
          <div class="stat-label">Zoom</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-res">0</div>
          <div class="stat-label">H3 Res</div>
        </div>
      </div>
    </div>
    <div class="info-section">
      <div class="info-section-label">Viewport</div>
      <div class="info-stats">
        <div class="stat" style="flex: 1">
          <div class="stat-value" id="stat-center" style="font-size: 13px">—</div>
          <div class="stat-label">Center</div>
        </div>
      </div>
    </div>
    <div class="info-section">
      <div class="info-section-label">Display Options</div>
      <div class="toggle-row">
        <span>Show airports</span>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-airports" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="toggle-row">
        <span>Show hex grid</span>
        <label class="toggle-switch">
          <input type="checkbox" id="toggle-grid" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="slider-row">
        <div class="slider-header">
          <span>Color scale</span>
          <span class="slider-value" id="color-scale-label">1.0×</span>
        </div>
        <input type="range" id="color-scale" min="0.5" max="4" step="0.1" value="1">
      </div>
    </div>
  </div>

  <!-- Legend -->
  <div class="legend">
    <h3>Travel Time</h3>
    <div class="legend-item"><div class="legend-color" style="background: #22c55e;"></div> < 2 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #84cc16;"></div> 2-4 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #eab308;"></div> 4-6 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #f97316;"></div> 6-8 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #ef4444;"></div> 8-10 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #dc2626;"></div> 10-12 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #a855f7;"></div> 12-14 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #7c3aed;"></div> 14-18 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #4c1d95;"></div> 18-24 hours</div>
    <div class="legend-item"><div class="legend-color" style="background: #1e1b4b;"></div> 24+ hours</div>
  </div>

  <!-- Tooltip -->
  <div class="tooltip" id="tooltip">
    <div class="tooltip-header">
      <div class="tooltip-location" id="tooltip-location">Paris, France</div>
      <div class="tooltip-time" id="tooltip-time">3h 45m</div>
    </div>
    <div class="tooltip-breakdown" id="tooltip-breakdown">
      <!-- populated dynamically by showTooltip() -->
    </div>
  </div>


  <!-- Loading overlay -->
  <div class="loading-overlay" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">Calculating travel times...</div>
  </div>

<script>
// =============================================================================
// DYNAMIC DATA LOADING
// =============================================================================

// loaded data (populated by loadJetSpanData)
let LOADED_AIRPORTS = null;  // {code: {name, lat, lng, country, type}}
let LOADED_ROUTES = null;    // {code: [destinations]}  (raw flight routes)
let LOADED_ISOCHRONE = null; // pre-computed isochrone data {resolutions: {res: {h3cell: {time, route}}}}
let DATA_LOADED = false;

// route table: per-airport routing info from dijkstra (loaded from routes.json)
// {airport_code: {p: [path], l: [leg_times], t: dijkstra_total, s: stops}}
let LOADED_ROUTE_TABLE = null;

// chunk loading state: track which parent cells have been fetched per resolution
const loadedChunks = { 5: new Set(), 6: new Set() };
let _chunkLoadingInProgress = false;

async function loadJetSpanData() {
  try {
    // load core data (airports + routes)
    const [airportsRes, routesRes] = await Promise.all([
      fetch('data/airports.json'),
      fetch('data/routes.json'),
    ]);

    if (airportsRes.ok && routesRes.ok) {
      LOADED_AIRPORTS = await airportsRes.json();
      LOADED_ROUTES = await routesRes.json();
      DATA_LOADED = true;
      console.log(`[JetSpan] Loaded ${Object.keys(LOADED_AIRPORTS).length} airports, ${Object.values(LOADED_ROUTES).reduce((a,b) => a + b.length, 0)} routes`);
    }
  } catch (e) {
    console.log('[JetSpan] Data files not found, using fallback data');
  }
}

// load pre-computed isochrone data for an origin
async function loadIsochroneData(originKey) {
  try {
    const res = await fetch(`data/isochrones/${originKey}.json`, {cache: 'no-cache'});
    if (res.ok) {
      LOADED_ISOCHRONE = await res.json();
      const totalCells = Object.values(LOADED_ISOCHRONE.resolutions).reduce((a, b) => a + Object.keys(b).length, 0);
      console.log(`[JetSpan] Loaded pre-computed isochrone for ${originKey}: ${totalCells} cells across ${Object.keys(LOADED_ISOCHRONE.resolutions).length} resolutions`);
      return LOADED_ISOCHRONE;
    }
  } catch (e) {
    console.log(`[JetSpan] No pre-computed isochrone for ${originKey}`);
  }
  LOADED_ISOCHRONE = null;
  return null;
}

// load route table for an origin (per-airport routing info for tooltips)
async function loadRouteTable(originKey) {
  try {
    const res = await fetch(`data/isochrones/${originKey}/routes.json`, {cache: 'no-cache'});
    if (res.ok) {
      LOADED_ROUTE_TABLE = await res.json();
      console.log(`[JetSpan] Loaded route table for ${originKey}: ${Object.keys(LOADED_ROUTE_TABLE).length} airports`);
      return LOADED_ROUTE_TABLE;
    }
  } catch (e) {
    console.log(`[JetSpan] No route table for ${originKey}`);
  }
  LOADED_ROUTE_TABLE = null;
  return null;
}

// determine which h3 parent cells are visible in the current viewport
function getVisibleParentCells(bounds, parentRes) {
  const cells = new Set();
  // step size in degrees — must be smaller than cell diameter to avoid gaps
  // res 1 cells ~4.7° across, res 2 cells ~1.8° across
  const step = parentRes === 1 ? 3 : 1;
  for (let lat = bounds.south; lat <= bounds.north; lat += step) {
    for (let lng = bounds.west; lng <= bounds.east; lng += step) {
      try {
        cells.add(h3.latLngToCell(lat, lng, parentRes));
      } catch (e) {
        // skip invalid coords
      }
    }
  }
  return [...cells];
}

// fetch and decompress a gzipped JSON file (chunks stored as .json.gz to save repo space)
async function fetchGzipJSON(url) {
  const res = await fetch(url, {cache: 'no-cache'});
  if (!res.ok) return null;
  const ds = new DecompressionStream('gzip');
  const stream = res.body.pipeThrough(ds);
  return new Response(stream).json();
}

// load chunked res 5-6 data for the visible viewport
async function loadChunksForViewport(resolution, bounds) {
  if (_chunkLoadingInProgress) return;
  _chunkLoadingInProgress = true;

  try {
    // res 5 chunks grouped by res-1 parent, res 6 by res-2 parent
    const parentRes = resolution === 5 ? 1 : 2;
    const needed = getVisibleParentCells(bounds, parentRes);
    const toFetch = needed.filter(p => !loadedChunks[resolution].has(p));

    if (toFetch.length === 0) {
      return; // all needed chunks already loaded
    }

    console.log(`[JetSpan] Loading ${toFetch.length} r${resolution} chunks...`);
    const t0 = performance.now();

    // fetch all needed chunks in parallel (gzipped, client decompresses)
    const results = await Promise.all(
      toFetch.map(parent =>
        fetchGzipJSON(`data/isochrones/${currentOrigin}/r${resolution}/${parent}.json.gz`)
          .catch(() => null)
      )
    );

    // merge into LOADED_ISOCHRONE
    if (!LOADED_ISOCHRONE.resolutions[String(resolution)]) {
      LOADED_ISOCHRONE.resolutions[String(resolution)] = {};
    }
    const resData = LOADED_ISOCHRONE.resolutions[String(resolution)];
    let loadedCells = 0;
    results.forEach((data, i) => {
      if (data) {
        Object.assign(resData, data);
        loadedCells += Object.keys(data).length;
        loadedChunks[resolution].add(toFetch[i]); // only mark loaded on success
      }
      // failed chunks NOT marked — will retry on next viewport update
    });

    const elapsed = performance.now() - t0;
    console.log(`[JetSpan] Loaded ${loadedCells} r${resolution} cells in ${elapsed.toFixed(0)}ms (${toFetch.length} chunks)`);
  } finally {
    _chunkLoadingInProgress = false;
  }
}

// parse pre-computed cell data into standard result format
// uses route table for exact breakdown when available
function parseCellData(cellData) {
  // compact format: {t, o, a, s} or {t, d} for drive-only
  if (!('t' in cellData)) {
    // legacy verbose format — shouldn't happen with new data
    return {
      totalMinutes: cellData.time || 0,
      breakdown: { groundTo: 0, overhead: 90, flight: 0, arrival: 60, groundFrom: 0, legs: [] },
      route: { originAirport: 'N/A', destAirport: 'N/A', isDirect: true, stops: 0, path: [] },
    };
  }

  if (cellData.d) {
    // drive-only cell
    return {
      totalMinutes: cellData.t,
      breakdown: { groundTo: cellData.t, overhead: 0, flight: 0, arrival: 0, groundFrom: 0, legs: [] },
      route: { originAirport: 'drive', destAirport: 'drive', isDirect: true, stops: -1, path: [] },
      osrm: !!cellData.g,  // true if ground time from OSRM road data
    };
  }

  // flight cell — use route table for exact breakdown when available
  const destCode = cellData.a || 'N/A';
  const stops = cellData.s || 0;
  const routeInfo = LOADED_ROUTE_TABLE?.[destCode];

  if (routeInfo) {
    // EXACT breakdown from route table
    // routeInfo: {p: [path], l: [leg_times], t: dijkstra_total, s: stops}
    const originCode = routeInfo.p[0];  // first airport in path

    // ground_to from ORIGINS config
    const originCity = ORIGINS[currentOrigin];
    let groundTo = 0;
    if (originCity) {
      if (originCity.nearestAirport?.code === originCode) {
        groundTo = originCity.nearestAirport.groundTimeMinutes || 0;
      } else {
        const alt = originCity.alternativeAirports?.find(a => a.code === originCode);
        groundTo = alt?.groundTimeMinutes || 0;
      }
    }

    const overhead = 90;
    // arrival overhead: domestic 30m, international 60m
    const originCountry = LOADED_AIRPORTS?.[originCode]?.country || '';
    const destCountry = LOADED_AIRPORTS?.[destCode]?.country || '';
    const arrival = (originCountry && destCountry && originCountry === destCountry) ? 30 : 60;
    // ground_from is EXACT: total cell time minus dijkstra total minus arrival
    const groundFrom = Math.max(0, cellData.t - routeInfo.t - arrival);

    return {
      totalMinutes: cellData.t,
      breakdown: {
        groundTo,
        overhead,
        flight: routeInfo.l.reduce((a, b) => a + b, 0),  // sum of per-leg times
        arrival,
        groundFrom,
        legs: routeInfo.l,  // per-leg flight times [105, 660]
      },
      route: {
        originAirport: originCode,
        destAirport: destCode,
        isDirect: stops === 0,
        stops,
        path: routeInfo.p,  // full airport sequence ["LHR", "FRA", "NRT"]
      },
      osrm: !!cellData.g,  // true if ground_from used OSRM road data
    };
  }

  // fallback: no route table, use residual estimation (legacy behavior)
  const originCode = cellData.o || 'N/A';
  const originCity = ORIGINS[currentOrigin];
  let groundTo = 0;
  if (originCity) {
    if (originCity.nearestAirport?.code === originCode) {
      groundTo = originCity.nearestAirport.groundTimeMinutes || 0;
    } else {
      const alt = originCity.alternativeAirports?.find(a => a.code === originCode);
      groundTo = alt?.groundTimeMinutes || 0;
    }
  }
  const overhead = 90;
  const connections = stops * 120;
  const originCountry = LOADED_AIRPORTS?.[originCode]?.country || '';
  const destCountry = LOADED_AIRPORTS?.[destCode]?.country || '';
  const arrival = (originCountry && destCountry && originCountry === destCountry) ? 30 : 60;
  const flight = Math.max(0, cellData.t - groundTo - overhead - connections - arrival);
  return {
    totalMinutes: cellData.t,
    breakdown: { groundTo, overhead, flight, arrival, groundFrom: 0, legs: [] },
    route: { originAirport: originCode, destAirport: destCode, isDirect: stops === 0, stops, path: [] },
    osrm: !!cellData.g,
  };
}

// lookup pre-computed travel time by H3 cell
function getPrecomputedTravelTime(h3Cell, resolution) {
  if (!LOADED_ISOCHRONE) return null;
  const resData = LOADED_ISOCHRONE.resolutions[String(resolution)];
  if (!resData) return null;
  const cellData = resData[h3Cell];
  if (!cellData) return null;
  return parseCellData(cellData);
}

// =============================================================================
// DIRECT RENDERING (skip grid iteration for pre-computed resolutions)
// =============================================================================
// For res 1-4 we have pre-computed data. Instead of iterating a grid of cells
// and checking each one, we directly iterate the pre-computed cells. This is
// O(pre-computed cells) instead of O(viewport cells).
// All resolutions (1-6) are pre-computed; res 5-6 lazy-loaded by viewport.
// =============================================================================

function generateHexGridDirect(origin, resolution, viewportBounds) {
  const startTotal = performance.now();

  if (!LOADED_ISOCHRONE) {
    console.log('[PERF] Direct render: no pre-computed data, falling back to grid');
    return null;
  }

  const resData = LOADED_ISOCHRONE.resolutions[String(resolution)];
  if (!resData) {
    console.log(`[PERF] Direct render: no res ${resolution} data, falling back to grid`);
    return null;
  }

  const features = [];
  const cells = Object.keys(resData);
  let inViewport = 0;
  let outViewport = 0;

  // use viewport bounds if provided
  const bounds = viewportBounds || { north: 85, south: -85, east: 180, west: -180 };
  // add padding to avoid edge artifacts
  const latPad = (bounds.north - bounds.south) * 0.15;
  const lngPad = (bounds.east - bounds.west) * 0.15;
  const padded = {
    north: Math.min(85, bounds.north + latPad),
    south: Math.max(-85, bounds.south - latPad),
    east: Math.min(180, bounds.east + lngPad),
    west: Math.max(-180, bounds.west - lngPad),
  };

  for (const h3Index of cells) {
    try {
      const centroid = h3.cellToLatLng(h3Index);
      const [lat, lng] = centroid;

      // simple viewport check (handles antimeridian edge cases roughly)
      const inLat = lat >= padded.south && lat <= padded.north;
      let inLng = lng >= padded.west && lng <= padded.east;
      // handle antimeridian wrap
      if (padded.west > padded.east) {
        inLng = lng >= padded.west || lng <= padded.east;
      }

      if (!inLat || !inLng) {
        outViewport++;
        continue;
      }
      inViewport++;

      const cellData = resData[h3Index];
      const result = parseCellData(cellData);

      const color = getTimeBandColor(result.totalMinutes);
      const boundary = h3.cellToBoundary(h3Index);

      // convert boundary to GeoJSON coordinates [lng, lat]
      let coordinates = boundary.map(([lat, lng]) => [lng, lat]);

      // handle antimeridian crossing
      const lngs = coordinates.map(c => c[0]);
      const hasPositive = lngs.some(lng => lng > 90);
      const hasNegative = lngs.some(lng => lng < -90);
      if (hasPositive && hasNegative) {
        coordinates = coordinates.map(([lng, lat]) => [
          lng < 0 ? lng + 360 : lng,
          lat
        ]);
      }
      coordinates.push(coordinates[0]); // close polygon

      features.push({
        type: 'Feature',
        properties: {
          h3Index,
          travelTimeMinutes: result.totalMinutes,
          color,
          breakdown: result.breakdown,
          route: result.route,
          centroid: [centroid[1], centroid[0]],
          osrm: result.osrm || false,
        },
        geometry: {
          type: 'Polygon',
          coordinates: [coordinates],
        }
      });
    } catch (e) {
      // skip invalid cells
    }
  }

  const elapsed = performance.now() - startTotal;
  console.log(`[PERF] Direct render res ${resolution}: ${inViewport} in-view, ${outViewport} out-of-view, ${elapsed.toFixed(0)}ms`);

  return {
    type: 'FeatureCollection',
    features,
  };
}

// =============================================================================
// DATA: Origins
// =============================================================================
const ORIGINS = {
  bristol: {
    name: 'Bristol, UK',
    coordinates: [-2.587, 51.454],
    nearestAirport: { code: 'BRS', name: 'Bristol Airport', coordinates: [-2.719, 51.382], groundTimeMinutes: 25 },
    alternativeAirports: [
      { code: 'LHR', name: 'London Heathrow', coordinates: [-0.461, 51.470], groundTimeMinutes: 120 },
      { code: 'LGW', name: 'London Gatwick', coordinates: [-0.190, 51.148], groundTimeMinutes: 150 },
      { code: 'BHX', name: 'Birmingham', coordinates: [-1.748, 52.454], groundTimeMinutes: 90 },
    ]
  },
  london: {
    name: 'London, UK',
    coordinates: [-0.118, 51.509],
    nearestAirport: { code: 'LHR', name: 'London Heathrow', coordinates: [-0.461, 51.470], groundTimeMinutes: 45 },
    alternativeAirports: [
      { code: 'LGW', name: 'London Gatwick', coordinates: [-0.190, 51.148], groundTimeMinutes: 60 },
      { code: 'STN', name: 'London Stansted', coordinates: [0.235, 51.885], groundTimeMinutes: 75 },
      { code: 'LTN', name: 'London Luton', coordinates: [-0.368, 51.875], groundTimeMinutes: 60 },
    ]
  },
  newyork: {
    name: 'New York, USA',
    coordinates: [-74.006, 40.713],
    nearestAirport: { code: 'JFK', name: 'JFK International', coordinates: [-73.778, 40.640], groundTimeMinutes: 45 },
    alternativeAirports: [
      { code: 'EWR', name: 'Newark Liberty', coordinates: [-74.169, 40.690], groundTimeMinutes: 40 },
      { code: 'LGA', name: 'LaGuardia', coordinates: [-73.872, 40.777], groundTimeMinutes: 35 },
    ]
  },
  paris: {
    name: 'Paris, France',
    coordinates: [2.352, 48.857],
    nearestAirport: { code: 'CDG', name: 'Paris Charles de Gaulle', coordinates: [2.548, 49.010], groundTimeMinutes: 45 },
    alternativeAirports: [
      { code: 'ORY', name: 'Paris Orly', coordinates: [2.365, 48.726], groundTimeMinutes: 35 },
    ]
  },
  tokyo: {
    name: 'Tokyo, Japan',
    coordinates: [139.692, 35.690],
    nearestAirport: { code: 'NRT', name: 'Narita International', coordinates: [140.386, 35.765], groundTimeMinutes: 75 },
    alternativeAirports: [
      { code: 'HND', name: 'Tokyo Haneda', coordinates: [139.779, 35.553], groundTimeMinutes: 45 },
    ]
  },
  sydney: {
    name: 'Sydney, Australia',
    coordinates: [151.209, -33.868],
    nearestAirport: { code: 'SYD', name: 'Sydney Kingsford Smith', coordinates: [151.177, -33.947], groundTimeMinutes: 30 },
    alternativeAirports: []
  }
};

// =============================================================================
// DATA: Airports (world major airports)
// =============================================================================
const AIRPORTS = [
  // UK
  { code: 'LHR', name: 'London Heathrow', coordinates: [-0.461, 51.470], country: 'UK' },
  { code: 'LGW', name: 'London Gatwick', coordinates: [-0.190, 51.148], country: 'UK' },
  { code: 'BRS', name: 'Bristol', coordinates: [-2.719, 51.382], country: 'UK' },
  { code: 'BHX', name: 'Birmingham', coordinates: [-1.748, 52.454], country: 'UK' },
  { code: 'MAN', name: 'Manchester', coordinates: [-2.275, 53.354], country: 'UK' },
  { code: 'EDI', name: 'Edinburgh', coordinates: [-3.373, 55.950], country: 'UK' },
  { code: 'GLA', name: 'Glasgow', coordinates: [-4.433, 55.872], country: 'UK' },
  { code: 'STN', name: 'London Stansted', coordinates: [0.235, 51.885], country: 'UK' },
  { code: 'LTN', name: 'London Luton', coordinates: [-0.368, 51.875], country: 'UK' },

  // Europe
  { code: 'CDG', name: 'Paris Charles de Gaulle', coordinates: [2.548, 49.010], country: 'France' },
  { code: 'ORY', name: 'Paris Orly', coordinates: [2.365, 48.726], country: 'France' },
  { code: 'AMS', name: 'Amsterdam Schiphol', coordinates: [4.764, 52.309], country: 'Netherlands' },
  { code: 'FRA', name: 'Frankfurt', coordinates: [8.571, 50.033], country: 'Germany' },
  { code: 'MUC', name: 'Munich', coordinates: [11.790, 48.354], country: 'Germany' },
  { code: 'MAD', name: 'Madrid Barajas', coordinates: [-3.567, 40.472], country: 'Spain' },
  { code: 'BCN', name: 'Barcelona El Prat', coordinates: [2.078, 41.297], country: 'Spain' },
  { code: 'FCO', name: 'Rome Fiumicino', coordinates: [12.251, 41.804], country: 'Italy' },
  { code: 'MXP', name: 'Milan Malpensa', coordinates: [8.728, 45.630], country: 'Italy' },
  { code: 'ZRH', name: 'Zurich', coordinates: [8.549, 47.464], country: 'Switzerland' },
  { code: 'GVA', name: 'Geneva', coordinates: [6.109, 46.238], country: 'Switzerland' },
  { code: 'VIE', name: 'Vienna', coordinates: [16.570, 48.110], country: 'Austria' },
  { code: 'BRU', name: 'Brussels', coordinates: [4.484, 50.901], country: 'Belgium' },
  { code: 'DUB', name: 'Dublin', coordinates: [-6.270, 53.421], country: 'Ireland' },
  { code: 'LIS', name: 'Lisbon', coordinates: [-9.136, 38.775], country: 'Portugal' },
  { code: 'ATH', name: 'Athens', coordinates: [23.944, 37.936], country: 'Greece' },
  { code: 'CPH', name: 'Copenhagen', coordinates: [12.656, 55.618], country: 'Denmark' },
  { code: 'OSL', name: 'Oslo', coordinates: [11.100, 60.121], country: 'Norway' },
  { code: 'ARN', name: 'Stockholm Arlanda', coordinates: [17.918, 59.652], country: 'Sweden' },
  { code: 'HEL', name: 'Helsinki', coordinates: [24.963, 60.317], country: 'Finland' },
  { code: 'WAW', name: 'Warsaw', coordinates: [20.967, 52.166], country: 'Poland' },
  { code: 'PRG', name: 'Prague', coordinates: [14.264, 50.101], country: 'Czech Republic' },
  { code: 'BUD', name: 'Budapest', coordinates: [19.261, 47.439], country: 'Hungary' },
  { code: 'IST', name: 'Istanbul', coordinates: [28.814, 41.261], country: 'Turkey' },

  // Middle East
  { code: 'DXB', name: 'Dubai', coordinates: [55.365, 25.253], country: 'UAE' },
  { code: 'DOH', name: 'Doha', coordinates: [51.608, 25.273], country: 'Qatar' },
  { code: 'AUH', name: 'Abu Dhabi', coordinates: [54.651, 24.433], country: 'UAE' },
  { code: 'TLV', name: 'Tel Aviv Ben Gurion', coordinates: [34.885, 32.009], country: 'Israel' },
  { code: 'CAI', name: 'Cairo', coordinates: [31.406, 30.111], country: 'Egypt' },

  // Asia
  { code: 'SIN', name: 'Singapore Changi', coordinates: [103.989, 1.350], country: 'Singapore' },
  { code: 'HKG', name: 'Hong Kong', coordinates: [113.915, 22.309], country: 'Hong Kong' },
  { code: 'NRT', name: 'Tokyo Narita', coordinates: [140.386, 35.765], country: 'Japan' },
  { code: 'HND', name: 'Tokyo Haneda', coordinates: [139.779, 35.553], country: 'Japan' },
  { code: 'ICN', name: 'Seoul Incheon', coordinates: [126.451, 37.460], country: 'South Korea' },
  { code: 'PEK', name: 'Beijing Capital', coordinates: [116.584, 40.080], country: 'China' },
  { code: 'PVG', name: 'Shanghai Pudong', coordinates: [121.805, 31.143], country: 'China' },
  { code: 'BKK', name: 'Bangkok Suvarnabhumi', coordinates: [100.747, 13.681], country: 'Thailand' },
  { code: 'KUL', name: 'Kuala Lumpur', coordinates: [101.700, 2.746], country: 'Malaysia' },
  { code: 'DEL', name: 'Delhi Indira Gandhi', coordinates: [77.103, 28.556], country: 'India' },
  { code: 'BOM', name: 'Mumbai', coordinates: [72.868, 19.089], country: 'India' },

  // North America
  { code: 'JFK', name: 'New York JFK', coordinates: [-73.778, 40.640], country: 'USA' },
  { code: 'EWR', name: 'Newark', coordinates: [-74.169, 40.690], country: 'USA' },
  { code: 'LGA', name: 'LaGuardia', coordinates: [-73.872, 40.777], country: 'USA' },
  { code: 'LAX', name: 'Los Angeles', coordinates: [-118.408, 33.942], country: 'USA' },
  { code: 'SFO', name: 'San Francisco', coordinates: [-122.375, 37.619], country: 'USA' },
  { code: 'ORD', name: 'Chicago O\'Hare', coordinates: [-87.905, 41.978], country: 'USA' },
  { code: 'DFW', name: 'Dallas Fort Worth', coordinates: [-97.038, 32.897], country: 'USA' },
  { code: 'MIA', name: 'Miami', coordinates: [-80.291, 25.795], country: 'USA' },
  { code: 'ATL', name: 'Atlanta', coordinates: [-84.428, 33.641], country: 'USA' },
  { code: 'SEA', name: 'Seattle', coordinates: [-122.309, 47.449], country: 'USA' },
  { code: 'BOS', name: 'Boston', coordinates: [-71.005, 42.365], country: 'USA' },
  { code: 'DEN', name: 'Denver', coordinates: [-104.673, 39.862], country: 'USA' },
  { code: 'YYZ', name: 'Toronto Pearson', coordinates: [-79.631, 43.677], country: 'Canada' },
  { code: 'YVR', name: 'Vancouver', coordinates: [-123.184, 49.195], country: 'Canada' },
  { code: 'YUL', name: 'Montreal', coordinates: [-73.741, 45.470], country: 'Canada' },
  { code: 'MEX', name: 'Mexico City', coordinates: [-99.072, 19.436], country: 'Mexico' },

  // South America
  { code: 'GRU', name: 'São Paulo Guarulhos', coordinates: [-46.473, -23.431], country: 'Brazil' },
  { code: 'EZE', name: 'Buenos Aires Ezeiza', coordinates: [-58.535, -34.822], country: 'Argentina' },
  { code: 'SCL', name: 'Santiago', coordinates: [-70.786, -33.393], country: 'Chile' },
  { code: 'BOG', name: 'Bogotá', coordinates: [-74.147, 4.702], country: 'Colombia' },
  { code: 'LIM', name: 'Lima', coordinates: [-77.114, -12.022], country: 'Peru' },

  // Africa
  { code: 'JNB', name: 'Johannesburg', coordinates: [28.231, -26.134], country: 'South Africa' },
  { code: 'CPT', name: 'Cape Town', coordinates: [18.602, -33.969], country: 'South Africa' },
  { code: 'NBO', name: 'Nairobi', coordinates: [36.928, -1.319], country: 'Kenya' },
  { code: 'ADD', name: 'Addis Ababa', coordinates: [38.799, 8.978], country: 'Ethiopia' },
  { code: 'LOS', name: 'Lagos', coordinates: [3.321, 6.577], country: 'Nigeria' },
  { code: 'CMN', name: 'Casablanca', coordinates: [-7.590, 33.367], country: 'Morocco' },

  // Oceania
  { code: 'SYD', name: 'Sydney', coordinates: [151.177, -33.947], country: 'Australia' },
  { code: 'MEL', name: 'Melbourne', coordinates: [144.843, -37.673], country: 'Australia' },
  { code: 'BNE', name: 'Brisbane', coordinates: [153.117, -27.384], country: 'Australia' },
  { code: 'PER', name: 'Perth', coordinates: [115.967, -31.940], country: 'Australia' },
  { code: 'AKL', name: 'Auckland', coordinates: [174.792, -37.008], country: 'New Zealand' },
];

// =============================================================================
// TIME BANDS (Galton-style colors)
// =============================================================================
const TIME_BANDS = [
  { maxHours: 2, color: '#22c55e', label: '< 2h' },      // green
  { maxHours: 4, color: '#84cc16', label: '2-4h' },      // lime
  { maxHours: 6, color: '#eab308', label: '4-6h' },      // yellow
  { maxHours: 8, color: '#f97316', label: '6-8h' },      // orange
  { maxHours: 10, color: '#ef4444', label: '8-10h' },    // red
  { maxHours: 12, color: '#dc2626', label: '10-12h' },   // dark red
  { maxHours: 14, color: '#a855f7', label: '12-14h' },   // purple - distinct from red
  { maxHours: 18, color: '#7c3aed', label: '14-18h' },   // violet
  { maxHours: 24, color: '#4c1d95', label: '18-24h' },   // deep purple
  { maxHours: Infinity, color: '#1e1b4b', label: '24h+' }, // near black purple
];

// color scale: multiplier on band thresholds (higher = more green)
let colorScale = 1.0;

// =============================================================================
// UTILITIES
// =============================================================================

function haversineDistance(coord1, coord2) {
  const R = 6371; // Earth radius in km
  const lat1 = coord1[1] * Math.PI / 180;
  const lat2 = coord2[1] * Math.PI / 180;
  const dLat = (coord2[1] - coord1[1]) * Math.PI / 180;
  const dLng = (coord2[0] - coord1[0]) * Math.PI / 180;

  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  return R * c;
}

function formatTime(minutes) {
  if (minutes >= 1440) {
    const days = Math.floor(minutes / 1440);
    const hours = Math.floor((minutes % 1440) / 60);
    return `${days}d ${hours}h`;
  }
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  if (hours === 0) return `${mins}m`;
  return `${hours}h ${mins.toString().padStart(2, '0')}m`;
}

// toggle info panel visibility
function toggleInfoPanel() {
  const panel = document.getElementById('info-panel');
  const btn = document.getElementById('info-btn');
  panel.classList.toggle('visible');
  btn.classList.toggle('active');
}

function getTimeBandColor(totalMinutes) {
  const hours = totalMinutes / 60;
  for (const band of TIME_BANDS) {
    // scale thresholds: higher colorScale = wider bands = more green
    if (hours < band.maxHours * colorScale) {
      return band.color;
    }
  }
  return TIME_BANDS[TIME_BANDS.length - 1].color;
}

// recolor existing grid features without regenerating geometry
function recolorGrid() {
  if (!gridData || !map) return;
  for (const f of gridData.features) {
    f.properties.color = getTimeBandColor(f.properties.travelTimeMinutes);
  }
  map.getSource('hexgrid').setData(gridData);
}

// update legend labels to reflect current color scale
function updateLegend() {
  const items = document.querySelectorAll('.legend-item');
  TIME_BANDS.forEach((band, i) => {
    if (!items[i]) return;
    const scaled = band.maxHours * colorScale;
    const prev = i > 0 ? TIME_BANDS[i - 1].maxHours * colorScale : 0;
    let label;
    if (i === 0) {
      label = `< ${formatBandHours(scaled)}`;
    } else if (band.maxHours === Infinity) {
      label = `${formatBandHours(prev)}+`;
    } else {
      label = `${formatBandHours(prev)}-${formatBandHours(scaled)}`;
    }
    // update just the text node (after the color swatch div)
    const textNode = items[i].childNodes[1];
    if (textNode) textNode.textContent = ' ' + label;
  });
}

function formatBandHours(h) {
  if (h >= 100) return Math.round(h) + 'h';
  if (h === Math.floor(h)) return h + 'h';
  return h.toFixed(1) + 'h';
}

// =============================================================================
// H3 GRID GENERATION
// =============================================================================

// all resolutions now precomputed — this is a thin wrapper for backward compat
// (benchmark code calls generateHexGrid directly)
function generateHexGrid(origin, resolution = 4, viewportBounds = null) {
  return generateHexGridDirect(origin, resolution, viewportBounds) ||
         { type: 'FeatureCollection', features: [] };
}

// =============================================================================
// MAP INITIALIZATION
// =============================================================================

let map;
let currentOrigin = 'bristol';
let gridData = null;
let currentResolution = 3;
let isUpdatingGrid = false;

function getResolutionForZoom(zoom) {
  // all resolutions precomputed: res 1-4 in base JSON, res 5-6 lazy-loaded chunks
  if (zoom < 1) return 1;       // far globe: res 1
  if (zoom < 2) return 2;       // globe: res 2
  if (zoom < 4.5) return 4;     // regional: res 4 (res 3 skipped — too coarse)
  if (zoom < 6.5) return 5;     // local: res 5 (chunked)
  return 6;                      // street: res 6 (chunked)
}

async function initMap() {
  // load external data (airports, routes)
  await loadJetSpanData();

  // load pre-computed isochrone data + route table for current origin
  await Promise.all([
    loadIsochroneData(currentOrigin),
    loadRouteTable(currentOrigin),
  ]);

  map = new maplibregl.Map({
    container: 'map',
    style: 'https://tiles.openfreemap.org/styles/positron',
    center: ORIGINS[currentOrigin].coordinates,
    zoom: 2,
  });

  // Enable globe projection after style loads (MapLibre v5+)
  map.on('style.load', () => {
    map.setProjection({ type: 'globe' });
  });

  map.addControl(new maplibregl.NavigationControl(), 'bottom-right');

  map.on('load', () => {
    // Add sources
    map.addSource('hexgrid', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] },
    });

    map.addSource('airports', {
      type: 'geojson',
      data: generateAirportGeoJSON(),
    });

    map.addSource('origin', {
      type: 'geojson',
      data: generateOriginGeoJSON(),
    });

    // Add layers - order matters! Hex grid first, then airports on top
    map.addLayer({
      id: 'hexgrid-fill',
      type: 'fill',
      source: 'hexgrid',
      paint: {
        'fill-color': ['get', 'color'],
        // Fade out very long travel times (mostly ocean/remote)
        'fill-opacity': [
          'interpolate', ['linear'],
          ['get', 'travelTimeMinutes'],
          0, 0.45,     // Near origin: semi-transparent
          360, 0.4,    // 6 hours
          600, 0.3,    // 10 hours
          840, 0.2,    // 14 hours
          1200, 0.1    // 20+ hours: very faint
        ],
      }
    });

    map.addLayer({
      id: 'hexgrid-line',
      type: 'line',
      source: 'hexgrid',
      paint: {
        'line-color': ['get', 'color'],
        'line-width': [
          'interpolate', ['linear'], ['zoom'],
          0, 0,      // No lines when zoomed out
          3, 0,      // Still no lines
          5, 0.3,    // Thin lines at medium zoom
          8, 0.5     // Slightly thicker when zoomed in
        ],
        'line-opacity': [
          'interpolate', ['linear'], ['zoom'],
          0, 0,
          3, 0,
          5, 0.1,
          8, 0.15
        ],
      }
    });

    map.addLayer({
      id: 'airports',
      type: 'circle',
      source: 'airports',
      paint: {
        'circle-radius': [
          'interpolate', ['linear'], ['zoom'],
          0, 1.5,    // tiny dots at globe view (3000+ airports)
          3, 2,
          5, 3.5,
          8, 6
        ],
        'circle-color': '#ffffff',
        'circle-stroke-color': '#1a1a1a',
        'circle-stroke-width': [
          'interpolate', ['linear'], ['zoom'],
          0, 0.5,
          5, 1.5,
          8, 2
        ],
        'circle-opacity': [
          'interpolate', ['linear'], ['zoom'],
          0, 0.5,
          4, 0.8,
          6, 1
        ],
      }
    });

    map.addLayer({
      id: 'airport-labels',
      type: 'symbol',
      source: 'airports',
      minzoom: 5,  // labels only at higher zoom (3000+ airports)
      layout: {
        'text-field': ['get', 'code'],
        'text-size': 10,
        'text-offset': [0, 1.2],
        'text-anchor': 'top',
        'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
        'text-allow-overlap': false,
        'text-optional': true,
      },
      paint: {
        'text-color': '#ffffff',
        'text-halo-color': '#000000',
        'text-halo-width': 1.5,
      }
    });

    map.addLayer({
      id: 'origin',
      type: 'circle',
      source: 'origin',
      paint: {
        'circle-radius': 12,
        'circle-color': '#22c55e',
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 3,
      }
    });

    // Add a pulsing effect layer for origin
    map.addLayer({
      id: 'origin-pulse',
      type: 'circle',
      source: 'origin',
      paint: {
        'circle-radius': 20,
        'circle-color': '#22c55e',
        'circle-opacity': 0.3,
      }
    }, 'origin');

    // Add country borders on top of hex grid
    // Use the existing OpenMapTiles vector source from the base style
    map.addLayer({
      id: 'country-borders',
      type: 'line',
      source: 'openmaptiles',
      'source-layer': 'boundary',
      filter: ['==', ['get', 'admin_level'], 2],
      paint: {
        'line-color': 'rgba(255, 255, 255, 0.6)',
        'line-width': [
          'interpolate', ['linear'], ['zoom'],
          1, 0.5,
          4, 1.5,
          8, 2.5
        ],
      }
    });

    // Route line visualization — shows flight path on hover
    map.addSource('route-line', {
      type: 'geojson',
      data: { type: 'FeatureCollection', features: [] }
    });

    // solid line for flight legs (airport → airport)
    map.addLayer({
      id: 'route-line-flights',
      type: 'line',
      source: 'route-line',
      filter: ['==', ['get', 'segment'], 'flight'],
      paint: {
        'line-color': '#ffffff',
        'line-width': 2.5,
        'line-opacity': 0.85
      }
    });

    // lighter dashed line for ground segment (last airport → cell centroid)
    map.addLayer({
      id: 'route-line-ground',
      type: 'line',
      source: 'route-line',
      filter: ['==', ['get', 'segment'], 'ground'],
      paint: {
        'line-color': '#ffffff',
        'line-width': 2,
        'line-opacity': 0.6,
        'line-dasharray': [4, 3]
      }
    });

    // Interaction
    map.on('mousemove', 'hexgrid-fill', (e) => {
      if (e.features.length > 0) {
        const props = e.features[0].properties;
        showTooltip(props);
        // draw route line on hover
        try {
          const route = JSON.parse(props.route);
          const centroid = JSON.parse(props.centroid);
          if (route && route.path) {
            map.getSource('route-line').setData(buildRouteGeoJSON(route, centroid));
          }
        } catch(e) {} // drive-only cells may lack route
      }
    });

    map.on('mouseleave', 'hexgrid-fill', () => {
      hideTooltip();
      // clear route line
      map.getSource('route-line').setData({ type: 'FeatureCollection', features: [] });
    });

    // Dynamic resolution and viewport-based rendering
    let moveDebounceTimer = null;
    let lastCenter = null;
    let lastZoom = null;

    map.on('moveend', () => {
      const zoom = map.getZoom();
      const center = map.getCenter();
      const newResolution = getResolutionForZoom(zoom);

      // Skip if viewport hasn't changed significantly (reduces unnecessary re-renders)
      if (lastCenter && lastZoom !== null) {
        const zoomDiff = Math.abs(zoom - lastZoom);
        const centerDiff = Math.abs(center.lng - lastCenter.lng) + Math.abs(center.lat - lastCenter.lat);
        // Skip for tiny movements (< 0.5 degree pan and < 0.3 zoom change)
        if (centerDiff < 0.5 && zoomDiff < 0.3) {
          return;
        }
      }
      lastCenter = center;
      lastZoom = zoom;

      // Regenerate grid when viewport changes (pan or zoom)
      if (!isUpdatingGrid) {
        clearTimeout(moveDebounceTimer);
        moveDebounceTimer = setTimeout(() => {
          currentResolution = newResolution;
          updateGrid(newResolution, false); // Don't fly to origin
        }, 350); // Debounce to reduce rapid re-renders during pan/zoom
      }
    });

    // Generate initial grid
    updateGrid();
  });
}

function generateAirportGeoJSON() {
  // show all airports reachable via route table (3000+)
  // falls back to hardcoded AIRPORTS if data not loaded yet
  if (LOADED_AIRPORTS && LOADED_ROUTE_TABLE) {
    const features = [];
    for (const code of Object.keys(LOADED_ROUTE_TABLE)) {
      const apt = LOADED_AIRPORTS[code];
      if (!apt) continue;
      features.push({
        type: 'Feature',
        properties: { code, name: apt.name || code, country: apt.country || '' },
        geometry: { type: 'Point', coordinates: [apt.lng, apt.lat] },
      });
    }
    // also add origin airports from ORIGINS config
    const origin = ORIGINS[currentOrigin];
    if (origin) {
      const originAirports = [origin.nearestAirport, ...(origin.alternativeAirports || [])];
      for (const aptCfg of originAirports) {
        const apt = LOADED_AIRPORTS[aptCfg.code];
        if (apt && !LOADED_ROUTE_TABLE[aptCfg.code]) {
          features.push({
            type: 'Feature',
            properties: { code: aptCfg.code, name: apt.name || aptCfg.code, country: apt.country || '' },
            geometry: { type: 'Point', coordinates: [apt.lng, apt.lat] },
          });
        }
      }
    }
    return { type: 'FeatureCollection', features };
  }
  // fallback: hardcoded list
  return {
    type: 'FeatureCollection',
    features: AIRPORTS.map(airport => ({
      type: 'Feature',
      properties: { code: airport.code, name: airport.name, country: airport.country },
      geometry: { type: 'Point', coordinates: airport.coordinates },
    })),
  };
}

function generateOriginGeoJSON() {
  const origin = ORIGINS[currentOrigin];
  return {
    type: 'Feature',
    properties: { name: origin.name },
    geometry: {
      type: 'Point',
      coordinates: origin.coordinates,
    }
  };
}

async function updateGrid(resolution = currentResolution, flyToOrigin = true) {
  if (isUpdatingGrid) return;
  isUpdatingGrid = true;

  // only show loading overlay for major changes (origin switch), not for pan/zoom
  const showLoading = flyToOrigin;
  if (showLoading) {
    document.getElementById('loading').classList.remove('hidden');
  }

  const origin = ORIGINS[currentOrigin];
  currentResolution = resolution;

  // get viewport bounds for efficient rendering
  // getBounds() is unreliable in globe projection at low zoom
  let viewportBounds = null;
  const zoom = map ? map.getZoom() : 0;

  if (map && map.getBounds && zoom >= 3) {
    const bounds = map.getBounds();
    const north = bounds.getNorth();
    const south = bounds.getSouth();
    const east = bounds.getEast();
    const west = bounds.getWest();

    if (north > south && Math.abs(east - west) < 360) {
      viewportBounds = { north, south, east, west };
    }
  }

  // for chunked resolutions (5-6), load needed chunks before rendering
  if (resolution >= 5 && LOADED_ISOCHRONE && viewportBounds) {
    await loadChunksForViewport(resolution, viewportBounds);
  }

  // render: direct from precomputed data at all resolutions
  gridData = generateHexGridDirect(origin, resolution, viewportBounds);
  if (!gridData || gridData.features.length === 0) {
    // fallback for edge cases (no data loaded yet)
    gridData = { type: 'FeatureCollection', features: [] };
  }

  map.getSource('hexgrid').setData(gridData);
  map.getSource('origin').setData(generateOriginGeoJSON());

  // update stats
  document.getElementById('stat-cells').textContent = gridData.features.length.toLocaleString();
  document.getElementById('stat-zoom').textContent = zoom.toFixed(1);
  document.getElementById('stat-res').textContent = resolution;
  const center = map.getCenter();
  document.getElementById('stat-center').textContent =
    `${center.lat.toFixed(3)}, ${center.lng.toFixed(3)}`;

  if (flyToOrigin) {
    map.flyTo({
      center: origin.coordinates,
      zoom: 4,
      duration: 1000,
    });
  }

  if (showLoading) {
    document.getElementById('loading').classList.add('hidden');
  }
  isUpdatingGrid = false;
}

// =============================================================================
// BENCHMARK — call from console: runBenchmark()
// waits for data load, shows visual overlay, tests zoom + pan, 3-run avg
// =============================================================================
async function runBenchmark() {
  // ensure data is loaded
  if (!LOADED_ISOCHRONE) {
    console.error('[BENCH] isochrone data not loaded yet — wait for page init');
    return null;
  }

  // visual overlay so you can watch
  let overlay = document.getElementById('bench-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'bench-overlay';
    overlay.style.cssText = `
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.85); color:#0f0; font-family:monospace;
      font-size:14px; padding:12px 20px; border-radius:8px; z-index:9999;
      border:1px solid #0f0; min-width:300px; text-align:center;
    `;
    document.body.appendChild(overlay);
  }
  const showStatus = (msg) => { overlay.textContent = msg; };

  const origin = ORIGINS[currentOrigin];
  const results = [];
  const RUNS = 3; // avg over this many runs

  // --- Phase 1: zoom sweep at origin center ---
  const zoomSteps = [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7];
  for (const z of zoomSteps) {
    showStatus(`ZOOM SWEEP: z=${z} ...`);
    map.jumpTo({center: origin.coordinates, zoom: z});
    await new Promise(r => setTimeout(r, 500)); // let maplibre fully settle

    const res = getResolutionForZoom(z);
    const bounds = map.getBounds();
    const vb = z >= 3 ? {
      north: bounds.getNorth(), south: bounds.getSouth(),
      east: bounds.getEast(), west: bounds.getWest()
    } : null;

    // warm-up run (fills caches)
    generateHexGrid(origin, res, vb);

    const times = [];
    for (let i = 0; i < RUNS; i++) {
      const t0 = performance.now();
      const grid = generateHexGrid(origin, res, vb);
      times.push({ms: performance.now() - t0, cells: grid.features.length});
    }
    const avgMs = times.reduce((s, t) => s + t.ms, 0) / times.length;
    results.push({
      test: 'zoom', zoom: z, res, cells: times[0].cells, path: 'precomputed',
      avgMs: +avgMs.toFixed(1), minMs: +Math.min(...times.map(t=>t.ms)).toFixed(1),
      maxMs: +Math.max(...times.map(t=>t.ms)).toFixed(1),
    });
    showStatus(`ZOOM z=${z} → res ${res} (precomputed): ${avgMs.toFixed(0)}ms, ${times[0].cells} cells`);
    await new Promise(r => setTimeout(r, 400)); // pause so user can read
  }

  // --- Phase 2: pan test at fixed zoom levels ---
  const panTargets = [
    {name: 'london',   coords: [-0.12, 51.51]},
    {name: 'paris',    coords: [2.35, 48.86]},
    {name: 'reykjavik', coords: [-21.9, 64.14]},
    {name: 'istanbul', coords: [28.98, 41.01]},
  ];
  const panZooms = [4, 5.5, 7];
  for (const z of panZooms) {
    for (const tgt of panTargets) {
      showStatus(`PAN TEST: z=${z} → ${tgt.name} ...`);
      map.jumpTo({center: tgt.coords, zoom: z});
      await new Promise(r => setTimeout(r, 500));

      const res = getResolutionForZoom(z);
      const bounds = map.getBounds();
      const vb = {
        north: bounds.getNorth(), south: bounds.getSouth(),
        east: bounds.getEast(), west: bounds.getWest()
      };

      generateHexGrid(origin, res, vb); // warm-up
      const times = [];
      for (let i = 0; i < RUNS; i++) {
        const t0 = performance.now();
        const grid = generateHexGrid(origin, res, vb);
        times.push({ms: performance.now() - t0, cells: grid.features.length});
      }
      const avgMs = times.reduce((s, t) => s + t.ms, 0) / times.length;
      results.push({
        test: `pan:${tgt.name}`, zoom: z, res, cells: times[0].cells, path: 'precomputed',
        avgMs: +avgMs.toFixed(1), minMs: +Math.min(...times.map(t=>t.ms)).toFixed(1),
        maxMs: +Math.max(...times.map(t=>t.ms)).toFixed(1),
      });
      showStatus(`PAN ${tgt.name} z=${z}: ${avgMs.toFixed(0)}ms, ${times[0].cells} cells`);
      await new Promise(r => setTimeout(r, 300));
    }
  }

  // --- Done ---
  const run = {
    timestamp: new Date().toISOString(),
    origin: currentOrigin,
    thresholds: zoomSteps.map(z => z + '→r' + getResolutionForZoom(z)).join(', '),
    results,
  };

  // log results
  console.log('\n[BENCH] ========== RESULTS ==========');
  console.log('[BENCH] timestamp:', run.timestamp);
  console.log('[BENCH] origin:', run.origin);
  console.log('[BENCH] thresholds:', run.thresholds);
  console.table(results);

  // diff against baseline if loaded
  if (window._benchBaseline) {
    const prev = window._benchBaseline;
    console.log('\n[BENCH] ========== DIFF vs BASELINE ==========');
    console.log('[BENCH] baseline:', prev.timestamp);
    const diffs = results.map((cur, i) => {
      const old = prev.results[i];
      if (!old) return null;
      const delta = cur.avgMs - old.avgMs;
      const pct = old.avgMs > 0 ? (delta / old.avgMs * 100).toFixed(1) : 'N/A';
      return {
        test: cur.test, zoom: cur.zoom, res: cur.res,
        prev: old.avgMs, curr: cur.avgMs,
        delta: +delta.toFixed(1), pct: pct + '%',
        cells_prev: old.cells, cells_curr: cur.cells,
      };
    }).filter(Boolean);
    console.table(diffs);
  }

  showStatus('BENCHMARK COMPLETE — see console, use benchExport() to save');
  setTimeout(() => overlay.remove(), 5000);

  window._lastBench = run;
  return run;
}

// benchExport(label) — download JSON file for committing to repo
// saves to docs/benchmarks/{label}.json
function benchExport(label) {
  const run = window._lastBench;
  if (!run) { console.error('[BENCH] no results — run runBenchmark() first'); return; }
  const filename = (label || 'bench-' + run.timestamp.slice(0, 10)) + '.json';
  const blob = new Blob([JSON.stringify(run, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
  console.log('[BENCH] exported:', filename, '— commit to docs/benchmarks/');
}

// benchLoadBaseline(url) — load a baseline JSON file for diffing
// e.g. benchLoadBaseline('docs/benchmarks/baseline.json')
async function benchLoadBaseline(url) {
  const resp = await fetch(url);
  window._benchBaseline = await resp.json();
  console.log('[BENCH] baseline loaded:', window._benchBaseline.timestamp);
}

// =============================================================================
// TEST SUITE — call from console: runTests()
// validates data existence, rendering, chunk loading, cell integrity
// =============================================================================
async function runTests() {
  if (!LOADED_ISOCHRONE) {
    console.error('[TEST] isochrone data not loaded — wait for page init');
    return null;
  }

  // visual overlay
  let overlay = document.getElementById('test-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'test-overlay';
    overlay.style.cssText = `
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.9); color:#0ff; font-family:monospace;
      font-size:13px; padding:12px 20px; border-radius:8px; z-index:9999;
      border:1px solid #0ff; min-width:400px; text-align:left;
      max-height:80vh; overflow-y:auto; white-space:pre-wrap;
    `;
    document.body.appendChild(overlay);
  }
  const lines = [];
  const show = (msg) => { lines.push(msg); overlay.textContent = lines.join('\n'); };

  const results = { pass: 0, fail: 0, errors: [] };
  function assert(condition, name) {
    if (condition) {
      results.pass++;
      show('  ✓ ' + name);
    } else {
      results.fail++;
      results.errors.push(name);
      show('  ✗ FAIL: ' + name);
    }
  }

  const origin = ORIGINS[currentOrigin];

  // === 1. DATA LOADING ===
  show('\n─── 1. Data Loading ───');
  assert(!!LOADED_ISOCHRONE, 'base isochrone data loaded');
  assert(!!LOADED_ROUTE_TABLE, 'route table loaded');
  assert(!!LOADED_AIRPORTS, 'airports data loaded');

  const resKeys = Object.keys(LOADED_ISOCHRONE.resolutions);
  assert(resKeys.length >= 4, 'has ' + resKeys.length + ' resolutions (need 4+)');

  for (const r of ['1', '2', '3', '4']) {
    const rd = LOADED_ISOCHRONE.resolutions[r];
    const count = rd ? Object.keys(rd).length : 0;
    assert(count > 0, 'res ' + r + ': ' + count + ' cells');
  }

  const routeCount = Object.keys(LOADED_ROUTE_TABLE).length;
  assert(routeCount > 3000, 'route table: ' + routeCount + ' airports');
  const aptCount = Object.keys(LOADED_AIRPORTS).length;
  assert(aptCount > 4000, 'airports: ' + aptCount);

  // === 2. RESOLUTION MAPPING ===
  show('\n─── 2. Resolution Mapping ───');
  const expectedRes = [
    [0.5, 1], [1.5, 2], [2.5, 4], [3.5, 4], [4.5, 5], [5.5, 5], [7, 6],
  ];
  for (const [z, expected] of expectedRes) {
    const got = getResolutionForZoom(z);
    assert(got === expected, 'zoom ' + z + ' → res ' + got + ' (expected ' + expected + ')');
  }

  // === 3. ZOOM SWEEP — render cells at each zoom ===
  show('\n─── 3. Zoom Sweep (origin center) ───');
  const zoomSteps = [0.5, 1, 1.5, 2, 3, 4, 4.5];
  for (const z of zoomSteps) {
    map.jumpTo({ center: origin.coordinates, zoom: z });
    await new Promise(r => setTimeout(r, 300));

    const res = getResolutionForZoom(z);
    const bounds = map.getBounds();
    const vb = z >= 2 ? {
      north: bounds.getNorth(), south: bounds.getSouth(),
      east: bounds.getEast(), west: bounds.getWest()
    } : null;

    const grid = generateHexGridDirect(origin, res, vb);
    const cells = grid ? grid.features.length : 0;
    assert(cells > 0, 'zoom ' + z + ' res ' + res + ': ' + cells + ' cells');

    // check features have valid properties
    if (grid && grid.features.length > 0) {
      const f = grid.features[0];
      assert(f.properties.color && f.properties.color.startsWith('#'),
        'feature has valid color: ' + f.properties.color);
      assert(f.properties.travelTimeMinutes > 0,
        'feature has positive travel time: ' + f.properties.travelTimeMinutes + 'min');
      assert(f.properties.breakdown, 'feature has breakdown');
      assert(f.properties.route, 'feature has route');
    }
  }

  // === 4. CHUNK LOADING (res 5) ===
  show('\n─── 4. Chunk Loading (res 5) ───');
  // clear loaded chunks to force reload
  loadedChunks[5] = new Set();
  loadedChunks[6] = new Set();
  if (LOADED_ISOCHRONE.resolutions['5']) delete LOADED_ISOCHRONE.resolutions['5'];
  if (LOADED_ISOCHRONE.resolutions['6']) delete LOADED_ISOCHRONE.resolutions['6'];

  map.jumpTo({ center: origin.coordinates, zoom: 5.5 });
  await new Promise(r => setTimeout(r, 500));

  const bounds5 = map.getBounds();
  const vb5 = {
    north: bounds5.getNorth(), south: bounds5.getSouth(),
    east: bounds5.getEast(), west: bounds5.getWest()
  };
  await loadChunksForViewport(5, vb5);

  const r5Data = LOADED_ISOCHRONE.resolutions['5'];
  const r5Count = r5Data ? Object.keys(r5Data).length : 0;
  assert(r5Count > 0, 'res 5 chunks loaded: ' + r5Count + ' cells');
  assert(loadedChunks[5].size > 0, 'chunk tracker: ' + loadedChunks[5].size + ' chunks');

  const grid5 = generateHexGridDirect(origin, 5, vb5);
  const cells5 = grid5 ? grid5.features.length : 0;
  assert(cells5 > 0, 'res 5 renders: ' + cells5 + ' cells');

  // === 5. CHUNK LOADING (res 6) ===
  show('\n─── 5. Chunk Loading (res 6) ───');
  map.jumpTo({ center: origin.coordinates, zoom: 7 });
  await new Promise(r => setTimeout(r, 500));

  const bounds6 = map.getBounds();
  const vb6 = {
    north: bounds6.getNorth(), south: bounds6.getSouth(),
    east: bounds6.getEast(), west: bounds6.getWest()
  };
  await loadChunksForViewport(6, vb6);

  const r6Data = LOADED_ISOCHRONE.resolutions['6'];
  const r6Count = r6Data ? Object.keys(r6Data).length : 0;
  assert(r6Count > 0, 'res 6 chunks loaded: ' + r6Count + ' cells');

  const grid6 = generateHexGridDirect(origin, 6, vb6);
  const cells6 = grid6 ? grid6.features.length : 0;
  assert(cells6 > 0, 'res 6 renders: ' + cells6 + ' cells');

  // === 6. PAN TEST — diverse locations ===
  show('\n─── 6. Pan Test (multiple locations) ───');
  const panTargets = [
    { name: 'london',    coords: [-0.12, 51.51],  zoom: 4 },
    { name: 'paris',     coords: [2.35, 48.86],   zoom: 4 },
    { name: 'reykjavik', coords: [-21.9, 64.14],  zoom: 4 },
    { name: 'istanbul',  coords: [28.98, 41.01],  zoom: 4 },
    { name: 'new-york',  coords: [-74.0, 40.71],  zoom: 4 },
    { name: 'tokyo',     coords: [139.69, 35.69], zoom: 4 },
    { name: 'bristol-close', coords: [-2.59, 51.45], zoom: 5.5 }, // chunk loading
  ];
  for (const tgt of panTargets) {
    map.jumpTo({ center: tgt.coords, zoom: tgt.zoom });
    await new Promise(r => setTimeout(r, 400));

    const res = getResolutionForZoom(tgt.zoom);
    const b = map.getBounds();
    const vb = { north: b.getNorth(), south: b.getSouth(), east: b.getEast(), west: b.getWest() };

    if (res >= 5) await loadChunksForViewport(res, vb);

    const grid = generateHexGridDirect(origin, res, vb);
    const cells = grid ? grid.features.length : 0;
    assert(cells > 0, tgt.name + ' z=' + tgt.zoom + ' res ' + res + ': ' + cells + ' cells');
  }

  // === 7. CELL DATA INTEGRITY ===
  show('\n─── 7. Cell Data Integrity ───');
  // sample res-4 cells and validate parseCellData output
  const res4 = LOADED_ISOCHRONE.resolutions['4'];
  const sampleKeys = Object.keys(res4).slice(0, 200);
  let validCells = 0, invalidCells = 0, driveOnlyCells = 0;
  let routeMatched = 0, routeMissing = 0;

  for (const key of sampleKeys) {
    const raw = res4[key];
    try {
      const parsed = parseCellData(raw);
      // basic sanity
      if (parsed.totalMinutes <= 0 || parsed.totalMinutes > 5000) { invalidCells++; continue; }
      if (!parsed.breakdown) { invalidCells++; continue; }
      if (!parsed.route) { invalidCells++; continue; }

      if (raw.d) {
        driveOnlyCells++;
        // drive-only: total should be reasonable (< 600 min from Bristol)
        if (parsed.totalMinutes > 600) invalidCells++;
        else validCells++;
      } else {
        validCells++;
        // flight cell: check route table consistency
        if (raw.a && LOADED_ROUTE_TABLE[raw.a]) routeMatched++;
        else if (raw.a) routeMissing++;

        // breakdown should sum approximately to total
        // connection overhead (~120min/stop) isn't a separate breakdown field
        const bd = parsed.breakdown;
        const stops = parsed.route.stops || 0;
        const connectionEst = stops * 120;
        const sum = bd.groundTo + bd.overhead + bd.flight + bd.arrival + bd.groundFrom + connectionEst;
        const diff = Math.abs(sum - parsed.totalMinutes);
        if (diff > 30) invalidCells++;
      }
    } catch (e) {
      invalidCells++;
    }
  }

  assert(validCells > 150, 'valid cells: ' + validCells + '/' + sampleKeys.length);
  assert(invalidCells < 5, 'invalid cells: ' + invalidCells + ' (< 5 allowed)');
  assert(routeMatched > 100, 'route table matches: ' + routeMatched);
  assert(routeMissing === 0, 'missing route entries: ' + routeMissing);
  show('    (drive-only: ' + driveOnlyCells + ')');

  // === 8. COLOR MAPPING ===
  show('\n─── 8. Color Mapping ───');
  const colorTests = [30, 60, 120, 240, 360, 480, 600, 720, 900, 1200, 1500];
  for (const mins of colorTests) {
    const color = getTimeBandColor(mins);
    assert(color && color.startsWith('#') && color.length === 7,
      mins + 'min → ' + color);
  }
  // color scale: changing it should shift colors
  const origScale = colorScale;
  colorScale = 2.0;
  const c1 = getTimeBandColor(300); // 5h at 2× scale
  colorScale = 0.5;
  const c2 = getTimeBandColor(300); // 5h at 0.5× scale
  colorScale = origScale; // restore
  assert(c1 !== c2, 'color scale shifts bands (2× → ' + c1 + ', 0.5× → ' + c2 + ')');

  // === 9. KNOWN ROUTES ===
  show('\n─── 9. Known Route Sanity ───');
  const knownRoutes = [
    { code: 'CDG', minT: 200, maxT: 500, stops: 0, desc: 'Paris CDG (direct)' },
    { code: 'JFK', minT: 400, maxT: 900, stops: 0, desc: 'New York JFK' },
    { code: 'NRT', minT: 600, maxT: 1500, stops: null, desc: 'Tokyo Narita' },
    { code: 'SYD', minT: 900, maxT: 2500, stops: null, desc: 'Sydney' },
  ];
  for (const kr of knownRoutes) {
    const rt = LOADED_ROUTE_TABLE[kr.code];
    if (!rt) { assert(false, kr.desc + ': not in route table'); continue; }
    assert(rt.t >= kr.minT && rt.t <= kr.maxT,
      kr.desc + ': ' + rt.t + 'min (expected ' + kr.minT + '-' + kr.maxT + ')');
    if (kr.stops !== null) {
      assert(rt.s === kr.stops, kr.desc + ': ' + rt.s + ' stops (expected ' + kr.stops + ')');
    }
    assert(rt.p.length >= 2, kr.desc + ': path has ' + rt.p.length + ' airports');
    assert(rt.l.length === rt.p.length - 1, kr.desc + ': legs match path length');
  }

  // === 10. DRIVE-ONLY ZONE ===
  show('\n─── 10. Drive-Only Zone ───');
  // cells near Bristol should be drive-only at res 4
  let driveCount = 0, flightNearOrigin = 0;
  for (const key of Object.keys(res4)) {
    const cell = res4[key];
    if (!cell.d) continue;
    driveCount++;
    // verify drive times are reasonable (< 10h from Bristol)
    if (cell.t > 600) {
      assert(false, 'drive-only cell with t=' + cell.t + 'min (too high)');
      break;
    }
  }
  assert(driveCount > 0, 'drive-only zone exists: ' + driveCount + ' cells at res 4');
  assert(driveCount < 500, 'drive-only zone not too large: ' + driveCount + ' cells');

  // === SUMMARY ===
  show('\n' + '═'.repeat(50));
  if (results.fail === 0) {
    show('ALL ' + results.pass + ' TESTS PASSED');
  } else {
    show(results.pass + ' passed, ' + results.fail + ' FAILED');
    show('failures:');
    for (const e of results.errors) show('  → ' + e);
  }
  show('═'.repeat(50));

  // restore map to sensible view
  map.jumpTo({ center: origin.coordinates, zoom: 4 });

  // auto-dismiss after 15s
  setTimeout(() => { if (overlay.parentNode) overlay.remove(); }, 15000);

  window._lastTests = results;
  console.log('[TEST] results:', results);
  return results;
}

function showTooltip(properties) {
  const tooltip = document.getElementById('tooltip');
  const breakdown = JSON.parse(properties.breakdown);
  const route = JSON.parse(properties.route);

  // find airport name for location display (prefer full dataset, fall back to hardcoded)
  const destAptData = LOADED_AIRPORTS?.[route.destAirport];
  const locationName = destAptData ? `Near ${destAptData.name}` : 'Location';

  document.getElementById('tooltip-location').textContent = locationName;
  document.getElementById('tooltip-time').textContent = formatTime(properties.travelTimeMinutes);
  document.getElementById('tooltip-time').style.color = properties.color;

  // build dynamic breakdown rows
  const container = document.getElementById('tooltip-breakdown');
  let html = '';

  if (route.stops === -1 || route.originAirport === 'drive') {
    // drive-only
    html += `<div class="breakdown-row route"><span>Drive only</span></div>`;
    html += row('Drive time', breakdown.groundTo);
  } else {
    // route line: Bristol → BRS ✈ AMS ✈ NRT → destination
    const originName = ORIGINS[currentOrigin].name.split(',')[0];
    const path = route.path;
    let routeStr;
    if (path && path.length > 0) {
      routeStr = `${originName} → ${path.join(' ✈ ')} → dest`;
    } else {
      routeStr = `${originName} → ${route.originAirport} ✈ ${route.destAirport}`;
    }
    html += `<div class="breakdown-row route"><span>${routeStr}</span></div>`;

    // ground to first airport
    const firstAirport = (path && path.length > 0) ? path[0] : route.originAirport;
    html += row(`Ground to ${firstAirport}`, breakdown.groundTo);
    html += row('Airport overhead', breakdown.overhead);

    // per-leg flight times (from route table) or lumped total
    const legs = breakdown.legs || [];
    if (legs.length > 0 && path && path.length > 1) {
      for (let i = 0; i < legs.length; i++) {
        const from = path[i];
        const to = path[i + 1];
        html += row(`${from} → ${to}`, legs[i]);
        // connection row between legs (not after last leg)
        if (i < legs.length - 1) {
          html += row(`Connection at ${to}`, 120); // 90 + 30
        }
      }
    } else {
      // no per-leg data, show total flight time
      html += row('Flight time', breakdown.flight);
    }

    // arrival + ground from airport
    html += row('Arrival + ground', breakdown.arrival + (breakdown.groundFrom || 0));
  }

  // debug: cell coords + OSRM status
  const centroid = JSON.parse(properties.centroid);
  const osrmFlag = properties.osrm ? 'OSRM' : 'haversine';
  html += `<div class="breakdown-row" style="opacity:0.5;font-size:11px;margin-top:4px">`;
  html += `<span>${centroid[1].toFixed(3)}, ${centroid[0].toFixed(3)}</span>`;
  html += `<span>ground: ${osrmFlag}</span>`;
  html += `</div>`;

  container.innerHTML = html;
  tooltip.classList.add('visible');

  // helper: one breakdown row
  function row(label, minutes) {
    return `<div class="breakdown-row"><span class="label">${label}</span><span class="value">${formatTime(minutes)}</span></div>`;
  }
}

function hideTooltip() {
  document.getElementById('tooltip').classList.remove('visible');
}

// build geojson for route line visualization on hover
// returns FeatureCollection with flight legs (solid) + ground segment (dashed)
function buildRouteGeoJSON(route, centroid) {
  const features = [];
  if (!route.path || route.path.length < 2) return { type: 'FeatureCollection', features };

  // flight legs: airport → airport along the path
  const flightCoords = [];
  for (const code of route.path) {
    const apt = LOADED_AIRPORTS?.[code];
    if (apt) flightCoords.push([apt.lng, apt.lat]);
  }

  if (flightCoords.length >= 2) {
    // handle antimeridian: if any pair of consecutive points spans >180° lng,
    // shift negative lngs to keep the line contiguous
    const needsShift = flightCoords.some((c, i) =>
      i > 0 && Math.abs(c[0] - flightCoords[i-1][0]) > 180
    );
    const adjusted = needsShift
      ? flightCoords.map(([lng, lat]) => [lng < 0 ? lng + 360 : lng, lat])
      : flightCoords;

    features.push({
      type: 'Feature',
      properties: { segment: 'flight' },
      geometry: { type: 'LineString', coordinates: adjusted }
    });

    // ground segment: last airport → cell centroid (lighter dashed line)
    if (centroid) {
      const lastApt = adjusted[adjusted.length - 1];
      let destLng = centroid[0];
      // match antimeridian shift if applied
      if (needsShift && destLng < 0) destLng += 360;
      features.push({
        type: 'Feature',
        properties: { segment: 'ground' },
        geometry: { type: 'LineString', coordinates: [lastApt, [destLng, centroid[1]]] }
      });
    }
  }

  return { type: 'FeatureCollection', features };
}

// =============================================================================
// EVENT LISTENERS
// =============================================================================

document.getElementById('toggle-airports').addEventListener('change', (e) => {
  const visibility = e.target.checked ? 'visible' : 'none';
  map.setLayoutProperty('airports', 'visibility', visibility);
  map.setLayoutProperty('airport-labels', 'visibility', visibility);
});

document.getElementById('toggle-grid').addEventListener('change', (e) => {
  const visibility = e.target.checked ? 'visible' : 'none';
  map.setLayoutProperty('hexgrid-fill', 'visibility', visibility);
  map.setLayoutProperty('hexgrid-line', 'visibility', visibility);
});

// color scale slider: recolor grid + update legend on change
document.getElementById('color-scale').addEventListener('input', (e) => {
  colorScale = parseFloat(e.target.value);
  document.getElementById('color-scale-label').textContent =
    colorScale.toFixed(1) + '×';
  recolorGrid();
  updateLegend();
});

// Initialize
initMap();
</script>
</body>
</html>
