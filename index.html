<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Shrinking World</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a1a;
      color: #eee;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .header {
      text-align: center;
      padding: 30px 20px 10px;
    }

    h1 {
      font-weight: 200;
      font-size: 2.5rem;
      color: #fff;
      margin-bottom: 8px;
    }

    .subtitle {
      color: #666;
      font-size: 1rem;
      font-weight: 300;
    }

    /* Tab navigation */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin: 20px 0;
    }

    .tab {
      padding: 10px 24px;
      background: transparent;
      border: 1px solid #333;
      color: #888;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s;
      border-radius: 4px;
    }

    .tab:hover {
      border-color: #555;
      color: #aaa;
    }

    .tab.active {
      background: #1a1a3a;
      border-color: #4a4a8a;
      color: #fff;
    }

    /* Panels */
    .panel {
      display: none;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .panel.active {
      display: block;
    }

    /* ===== MORPH VIEW ===== */
    .morph-container {
      position: relative;
    }

    .morph-svg {
      width: 100%;
      height: 70vh;
      background: #0d0d20;
      border-radius: 12px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      padding: 20px;
      background: #111128;
      border-radius: 8px;
    }

    .slider-label {
      font-size: 0.9rem;
      color: #888;
      min-width: 120px;
    }

    .slider-label.left { text-align: right; }
    .slider-label.right { text-align: left; }

    .warp-slider {
      width: 400px;
      height: 8px;
      -webkit-appearance: none;
      background: linear-gradient(to right, #2a4a6a, #6a2a6a);
      border-radius: 4px;
      outline: none;
    }

    .warp-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      cursor: grab;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .warp-slider::-webkit-slider-thumb:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    .warp-value {
      font-size: 2rem;
      font-weight: 200;
      color: #fff;
      min-width: 80px;
      text-align: center;
    }

    .stat-row {
      display: flex;
      justify-content: center;
      gap: 60px;
      margin-top: 15px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 200;
      color: #58c4dc;
    }

    .stat-label {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .play-btn {
      padding: 12px 30px;
      background: linear-gradient(135deg, #4a4a8a, #6a4a8a);
      border: none;
      color: #fff;
      font-size: 0.9rem;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .play-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 20px rgba(100, 100, 200, 0.3);
    }

    /* ===== SPLIT VIEW ===== */
    .split-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .split-panel {
      background: #0d0d20;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }

    .split-panel h3 {
      position: absolute;
      top: 15px;
      left: 20px;
      font-weight: 400;
      font-size: 1rem;
      z-index: 10;
    }

    .split-panel .panel-stat {
      position: absolute;
      bottom: 15px;
      left: 20px;
      font-size: 0.8rem;
      color: #666;
    }

    .split-svg {
      width: 100%;
      height: 60vh;
    }

    /* ===== HISTORICAL VIEW ===== */
    .historical-container {
      text-align: center;
    }

    .era-selector {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .era-btn {
      padding: 12px 24px;
      background: #1a1a3a;
      border: 1px solid #333;
      color: #888;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.3s;
    }

    .era-btn:hover {
      border-color: #555;
    }

    .era-btn.active {
      background: linear-gradient(135deg, #2a4a6a, #4a2a6a);
      border-color: #6a6aaa;
      color: #fff;
    }

    .era-description {
      color: #666;
      font-size: 0.9rem;
      margin-bottom: 20px;
      min-height: 40px;
    }

    .historical-svg {
      width: 100%;
      height: 65vh;
      background: #0d0d20;
      border-radius: 12px;
    }

    .journey-times {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .journey {
      background: #111128;
      padding: 15px 25px;
      border-radius: 8px;
      text-align: left;
    }

    .journey-route {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 5px;
    }

    .journey-time {
      font-size: 1.3rem;
      font-weight: 300;
    }

    /* ===== MAP STYLES ===== */
    .land {
      fill: #1a1a3a;
      stroke: #2a2a5a;
      stroke-width: 0.5;
    }

    .land-ghost {
      fill: none;
      stroke: #2a2a4a;
      stroke-width: 0.3;
    }

    .city-dot {
      cursor: pointer;
      transition: r 0.2s;
    }

    .city-dot:hover {
      filter: brightness(1.3);
    }

    .city-label {
      font-size: 9px;
      fill: #888;
      pointer-events: none;
    }

    .origin-marker {
      fill: #ff6b6b;
      filter: drop-shadow(0 0 8px rgba(255, 107, 107, 0.5));
    }

    .trail-line {
      stroke: #4a4a6a;
      stroke-width: 1;
      opacity: 0.4;
    }

    .highlight-ring {
      fill: none;
      stroke: #fff;
      stroke-width: 2;
      opacity: 0;
    }

    .tooltip {
      position: fixed;
      background: rgba(0,0,0,0.9);
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-city {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .tooltip-stats {
      color: #888;
      font-size: 0.75rem;
    }

    /* Animated elements */
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .pulsing {
      animation: pulse 2s infinite;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>The Shrinking World</h1>
    <p class="subtitle">How air travel warps our perception of distance</p>
  </div>

  <div class="tabs">
    <button class="tab active" data-panel="morph">Interactive Morph</button>
    <button class="tab" data-panel="split">Before / After</button>
    <button class="tab" data-panel="historical">Historical Eras</button>
  </div>

  <!-- MORPH PANEL -->
  <div class="panel active" id="panel-morph">
    <div class="morph-container">
      <svg class="morph-svg" id="morph-svg"></svg>

      <div class="slider-container">
        <span class="slider-label left">Geographic Distance</span>
        <input type="range" class="warp-slider" id="warp-slider" min="0" max="100" value="0">
        <span class="slider-label right">Flight Time</span>
        <button class="play-btn" id="play-btn">▶ Animate</button>
      </div>

      <div class="stat-row">
        <div class="stat">
          <div class="stat-value" id="stat-warp">0%</div>
          <div class="stat-label">Time-Space Warp</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-spread">100%</div>
          <div class="stat-label">World Size</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-avg">—</div>
          <div class="stat-label">Avg Distance to London</div>
        </div>
      </div>
    </div>
  </div>

  <!-- SPLIT PANEL -->
  <div class="panel" id="panel-split">
    <div class="split-container">
      <div class="split-panel">
        <h3>Geographic Reality</h3>
        <div class="panel-stat">Distance in kilometers</div>
        <svg class="split-svg" id="split-geo"></svg>
      </div>
      <div class="split-panel">
        <h3>Time-Space Reality</h3>
        <div class="panel-stat">Distance in flight hours</div>
        <svg class="split-svg" id="split-time"></svg>
      </div>
    </div>
  </div>

  <!-- HISTORICAL PANEL -->
  <div class="panel" id="panel-historical">
    <div class="historical-container">
      <div class="era-selector">
        <button class="era-btn active" data-era="1914">1914</button>
        <button class="era-btn" data-era="1950">1950</button>
        <button class="era-btn" data-era="1970">1970</button>
        <button class="era-btn" data-era="2024">2024</button>
      </div>
      <div class="era-description" id="era-description">
        Steamships and railways. London to New York: 7 days. London to Sydney: 40+ days.
      </div>
      <svg class="historical-svg" id="historical-svg"></svg>
      <div class="journey-times" id="journey-times"></div>
    </div>
  </div>

  <div class="tooltip" id="tooltip">
    <div class="tooltip-city"></div>
    <div class="tooltip-stats"></div>
  </div>

  <script>
    // ============================================
    // DATA
    // ============================================
    const origin = { code: "LHR", city: "London", lat: 51.47, lng: -0.4543 };

    const cities = [
      // European hubs
      { code: "CDG", city: "Paris", lat: 49.01, lng: 2.55, flightMinutes: 75, connectivity: 9 },
      { code: "AMS", city: "Amsterdam", lat: 52.31, lng: 4.77, flightMinutes: 75, connectivity: 9 },
      { code: "FRA", city: "Frankfurt", lat: 50.04, lng: 8.56, flightMinutes: 100, connectivity: 9 },
      { code: "MAD", city: "Madrid", lat: 40.50, lng: -3.57, flightMinutes: 150, connectivity: 8 },
      { code: "FCO", city: "Rome", lat: 41.80, lng: 12.24, flightMinutes: 155, connectivity: 7 },
      { code: "ARN", city: "Stockholm", lat: 59.65, lng: 17.92, flightMinutes: 145, connectivity: 6 },
      { code: "CPH", city: "Copenhagen", lat: 55.62, lng: 12.66, flightMinutes: 115, connectivity: 6 },
      { code: "VIE", city: "Vienna", lat: 48.11, lng: 16.57, flightMinutes: 140, connectivity: 6 },
      { code: "ZRH", city: "Zurich", lat: 47.46, lng: 8.55, flightMinutes: 110, connectivity: 7 },
      { code: "LIS", city: "Lisbon", lat: 38.77, lng: -9.13, flightMinutes: 165, connectivity: 6 },
      { code: "ATH", city: "Athens", lat: 37.94, lng: 23.94, flightMinutes: 220, connectivity: 5 },
      { code: "IST", city: "Istanbul", lat: 41.26, lng: 28.74, flightMinutes: 235, connectivity: 8 },
      // Transatlantic
      { code: "JFK", city: "New York", lat: 40.64, lng: -73.78, flightMinutes: 450, connectivity: 10 },
      { code: "LAX", city: "Los Angeles", lat: 33.94, lng: -118.41, flightMinutes: 660, connectivity: 9 },
      { code: "ORD", city: "Chicago", lat: 41.98, lng: -87.90, flightMinutes: 510, connectivity: 8 },
      { code: "MIA", city: "Miami", lat: 25.80, lng: -80.29, flightMinutes: 555, connectivity: 7 },
      { code: "YYZ", city: "Toronto", lat: 43.68, lng: -79.63, flightMinutes: 465, connectivity: 7 },
      { code: "SFO", city: "San Francisco", lat: 37.62, lng: -122.38, flightMinutes: 645, connectivity: 8 },
      // Middle East
      { code: "DXB", city: "Dubai", lat: 25.25, lng: 55.36, flightMinutes: 420, connectivity: 10 },
      { code: "DOH", city: "Doha", lat: 25.27, lng: 51.61, flightMinutes: 405, connectivity: 9 },
      // Asia
      { code: "HND", city: "Tokyo", lat: 35.55, lng: 139.78, flightMinutes: 720, connectivity: 9 },
      { code: "SIN", city: "Singapore", lat: 1.36, lng: 103.99, flightMinutes: 780, connectivity: 10 },
      { code: "HKG", city: "Hong Kong", lat: 22.31, lng: 113.91, flightMinutes: 720, connectivity: 9 },
      { code: "DEL", city: "Delhi", lat: 28.56, lng: 77.10, flightMinutes: 510, connectivity: 7 },
      { code: "BKK", city: "Bangkok", lat: 13.69, lng: 100.75, flightMinutes: 690, connectivity: 8 },
      { code: "PEK", city: "Beijing", lat: 40.08, lng: 116.58, flightMinutes: 600, connectivity: 8 },
      // Southern hemisphere
      { code: "SYD", city: "Sydney", lat: -33.95, lng: 151.18, flightMinutes: 1320, connectivity: 7 },
      { code: "JNB", city: "Johannesburg", lat: -26.14, lng: 28.24, flightMinutes: 660, connectivity: 6 },
      { code: "GRU", city: "São Paulo", lat: -23.43, lng: -46.47, flightMinutes: 720, connectivity: 7 },
      { code: "EZE", city: "Buenos Aires", lat: -34.82, lng: -58.54, flightMinutes: 810, connectivity: 5 },
      // Remote
      { code: "KEF", city: "Reykjavik", lat: 63.99, lng: -22.62, flightMinutes: 195, connectivity: 4 },
      { code: "AKL", city: "Auckland", lat: -37.01, lng: 174.79, flightMinutes: 1440, connectivity: 4 },
    ];

    // Historical travel times (in minutes)
    const historicalTimes = {
      1914: { // Steamships + rail
        JFK: 7 * 24 * 60,      // 7 days
        SYD: 42 * 24 * 60,     // 42 days
        HND: 35 * 24 * 60,     // 35 days
        CDG: 8 * 60,           // 8 hours by train
        DXB: 21 * 24 * 60,     // 21 days
        JNB: 25 * 24 * 60,     // 25 days
        SIN: 28 * 24 * 60,     // 28 days
        default: (city) => city.flightMinutes * 30 // rough multiplier
      },
      1950: { // Early commercial aviation
        JFK: 18 * 60,          // 18 hours (with stops)
        SYD: 4 * 24 * 60,      // 4 days (many stops)
        HND: 36 * 60,          // 36 hours
        CDG: 2 * 60,           // 2 hours
        DXB: 12 * 60,          // 12 hours
        JNB: 24 * 60,          // 24 hours
        SIN: 30 * 60,          // 30 hours
        default: (city) => city.flightMinutes * 3
      },
      1970: { // Jet age
        JFK: 7 * 60,           // 7 hours
        SYD: 26 * 60,          // 26 hours (1 stop)
        HND: 14 * 60,          // 14 hours
        CDG: 75,               // 1h 15m
        DXB: 7 * 60,           // 7 hours
        JNB: 11 * 60,          // 11 hours
        SIN: 14 * 60,          // 14 hours
        default: (city) => city.flightMinutes * 1.3
      },
      2024: { // Modern
        default: (city) => city.flightMinutes
      }
    };

    const eraDescriptions = {
      1914: "Steamships and railways. London to New York: 7 days. London to Sydney: 42 days.",
      1950: "Early commercial aviation. Propeller planes with multiple fuel stops.",
      1970: "The jet age. Boeing 747 revolutionizes long-haul travel.",
      2024: "Modern aviation. Non-stop flights connect most major cities."
    };

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    const timeColorScale = d3.scaleSequential(d3.interpolateViridis)
      .domain([1500, 60]);

    function bearing(lat1, lng1, lat2, lng2) {
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const y = Math.sin(dLng) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
      return Math.atan2(y, x);
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function formatTime(minutes) {
      if (minutes >= 24 * 60) {
        const days = Math.round(minutes / (24 * 60));
        return `${days} day${days > 1 ? 's' : ''}`;
      }
      const hours = Math.floor(minutes / 60);
      const mins = Math.round(minutes % 60);
      if (hours === 0) return `${mins}m`;
      if (mins === 0) return `${hours}h`;
      return `${hours}h ${mins}m`;
    }

    function getTravelTime(city, era) {
      const times = historicalTimes[era];
      if (times[city.code]) return times[city.code];
      return times.default(city);
    }

    // ============================================
    // TOOLTIP
    // ============================================
    const tooltip = d3.select("#tooltip");

    function showTooltip(event, city, warpAmount = 0) {
      const geoDistance = haversineDistance(origin.lat, origin.lng, city.lat, city.lng);
      tooltip.select(".tooltip-city").text(`${city.city} (${city.code})`);
      tooltip.select(".tooltip-stats").html(`
        Geographic: ${Math.round(geoDistance).toLocaleString()} km<br>
        Flight time: ${formatTime(city.flightMinutes)}
      `);
      tooltip
        .style("left", (event.clientX + 15) + "px")
        .style("top", (event.clientY - 10) + "px")
        .classed("visible", true);
    }

    function hideTooltip() {
      tooltip.classed("visible", false);
    }

    // ============================================
    // TAB NAVIGATION
    // ============================================
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`panel-${tab.dataset.panel}`).classList.add('active');
      });
    });

    // ============================================
    // MORPH VIEW
    // ============================================
    let morphProjection, morphPath, morphSvg, morphWidth, morphHeight;
    let cityElements = [];

    function initMorphView(land) {
      const container = document.getElementById('morph-svg');
      morphWidth = container.clientWidth;
      morphHeight = container.clientHeight;

      morphProjection = d3.geoNaturalEarth1()
        .center([10, 25])
        .scale(morphWidth / 5.5)
        .translate([morphWidth / 2, morphHeight / 2]);

      morphPath = d3.geoPath(morphProjection);

      morphSvg = d3.select("#morph-svg")
        .attr("viewBox", `0 0 ${morphWidth} ${morphHeight}`);

      // Draw land
      morphSvg.append("path")
        .datum(land)
        .attr("class", "land")
        .attr("d", morphPath);

      const originPos = morphProjection([origin.lng, origin.lat]);

      // Precompute positions
      cities.forEach(city => {
        city.geoPos = morphProjection([city.lng, city.lat]);
        city.geoDistance = haversineDistance(origin.lat, origin.lng, city.lat, city.lng);

        // Calculate warped position
        const bear = bearing(origin.lat, origin.lng, city.lat, city.lng);
        const timeScale = 0.25; // pixels per minute
        const warpedDistance = city.flightMinutes * timeScale;
        city.warpPos = [
          originPos[0] + warpedDistance * Math.sin(bear),
          originPos[1] - warpedDistance * Math.cos(bear)
        ];
      });

      // Draw trail lines (from origin to each city)
      const trails = morphSvg.append("g").attr("class", "trails");
      cities.forEach(city => {
        trails.append("line")
          .attr("class", "trail-line")
          .attr("x1", originPos[0])
          .attr("y1", originPos[1])
          .attr("x2", city.geoPos[0])
          .attr("y2", city.geoPos[1])
          .attr("data-code", city.code);
      });

      // Draw cities
      const cityGroup = morphSvg.append("g").attr("class", "cities");
      cities.forEach(city => {
        const size = 4 + city.connectivity * 0.5;

        const g = cityGroup.append("g")
          .attr("class", "city-group")
          .attr("data-code", city.code);

        g.append("circle")
          .attr("class", "city-dot")
          .attr("cx", city.geoPos[0])
          .attr("cy", city.geoPos[1])
          .attr("r", size)
          .attr("fill", timeColorScale(city.flightMinutes))
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .on("mouseenter", (e) => showTooltip(e, city))
          .on("mouseleave", hideTooltip);

        g.append("text")
          .attr("class", "city-label")
          .attr("x", city.geoPos[0])
          .attr("y", city.geoPos[1] - size - 3)
          .attr("text-anchor", "middle")
          .text(city.code);

        cityElements.push({ city, g, size });
      });

      // Draw origin
      morphSvg.append("circle")
        .attr("class", "origin-marker")
        .attr("cx", originPos[0])
        .attr("cy", originPos[1])
        .attr("r", 8);

      morphSvg.append("text")
        .attr("x", originPos[0])
        .attr("y", originPos[1] - 15)
        .attr("text-anchor", "middle")
        .attr("fill", "#ff6b6b")
        .attr("font-weight", "600")
        .attr("font-size", "12px")
        .text("LONDON");

      // Slider interaction
      const slider = document.getElementById('warp-slider');
      slider.addEventListener('input', (e) => updateMorph(e.target.value / 100));

      // Play button
      const playBtn = document.getElementById('play-btn');
      let playing = false;
      let animationFrame;

      playBtn.addEventListener('click', () => {
        if (playing) {
          playing = false;
          playBtn.textContent = "▶ Animate";
          cancelAnimationFrame(animationFrame);
        } else {
          playing = true;
          playBtn.textContent = "⏸ Pause";
          slider.value = 0;
          animateMorph();
        }
      });

      function animateMorph() {
        if (!playing) return;
        let value = parseFloat(slider.value);
        value += 0.5;
        if (value > 100) {
          value = 100;
          playing = false;
          playBtn.textContent = "▶ Animate";
        }
        slider.value = value;
        updateMorph(value / 100);
        if (playing) {
          animationFrame = requestAnimationFrame(animateMorph);
        }
      }

      updateMorph(0);
    }

    function updateMorph(t) {
      const originPos = morphProjection([origin.lng, origin.lat]);

      // Update city positions
      cityElements.forEach(({ city, g, size }) => {
        const x = city.geoPos[0] + (city.warpPos[0] - city.geoPos[0]) * t;
        const y = city.geoPos[1] + (city.warpPos[1] - city.geoPos[1]) * t;

        g.select("circle")
          .attr("cx", x)
          .attr("cy", y);

        g.select("text")
          .attr("x", x)
          .attr("y", y - size - 3);
      });

      // Update trail lines
      morphSvg.selectAll(".trail-line").each(function() {
        const code = d3.select(this).attr("data-code");
        const city = cities.find(c => c.code === code);
        const x = city.geoPos[0] + (city.warpPos[0] - city.geoPos[0]) * t;
        const y = city.geoPos[1] + (city.warpPos[1] - city.geoPos[1]) * t;
        d3.select(this)
          .attr("x2", x)
          .attr("y2", y)
          .attr("opacity", 0.2 + t * 0.3);
      });

      // Update stats
      document.getElementById('stat-warp').textContent = Math.round(t * 100) + '%';

      // Calculate "world size" - average distance from origin
      const avgGeoDistance = d3.mean(cities, c => {
        const dx = c.geoPos[0] - originPos[0];
        const dy = c.geoPos[1] - originPos[1];
        return Math.sqrt(dx*dx + dy*dy);
      });

      const avgCurrentDistance = d3.mean(cities, c => {
        const x = c.geoPos[0] + (c.warpPos[0] - c.geoPos[0]) * t;
        const y = c.geoPos[1] + (c.warpPos[1] - c.geoPos[1]) * t;
        const dx = x - originPos[0];
        const dy = y - originPos[1];
        return Math.sqrt(dx*dx + dy*dy);
      });

      const worldSize = Math.round((avgCurrentDistance / avgGeoDistance) * 100);
      document.getElementById('stat-spread').textContent = worldSize + '%';

      // Average flight time display
      const avgTime = d3.mean(cities, c => c.flightMinutes);
      document.getElementById('stat-avg').textContent = formatTime(avgTime);
    }

    // ============================================
    // SPLIT VIEW
    // ============================================
    function initSplitView(land) {
      ['geo', 'time'].forEach((type, idx) => {
        const container = document.getElementById(`split-${type}`);
        const width = container.clientWidth;
        const height = container.clientHeight;

        const projection = d3.geoNaturalEarth1()
          .center([10, 25])
          .scale(width / 3)
          .translate([width / 2, height / 2]);

        const path = d3.geoPath(projection);

        const svg = d3.select(`#split-${type}`)
          .attr("viewBox", `0 0 ${width} ${height}`);

        svg.append("path")
          .datum(land)
          .attr("class", type === 'geo' ? "land" : "land-ghost")
          .attr("d", path);

        const originPos = projection([origin.lng, origin.lat]);

        cities.forEach(city => {
          let pos;
          if (type === 'geo') {
            pos = projection([city.lng, city.lat]);
          } else {
            const bear = bearing(origin.lat, origin.lng, city.lat, city.lng);
            const timeScale = 0.35;
            const warpedDistance = city.flightMinutes * timeScale;
            pos = [
              originPos[0] + warpedDistance * Math.sin(bear),
              originPos[1] - warpedDistance * Math.cos(bear)
            ];
          }

          if (!pos) return;

          const size = 4 + city.connectivity * 0.4;

          svg.append("circle")
            .attr("class", "city-dot")
            .attr("cx", pos[0])
            .attr("cy", pos[1])
            .attr("r", size)
            .attr("fill", timeColorScale(city.flightMinutes))
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
            .attr("data-code", city.code)
            .on("mouseenter", (e) => {
              showTooltip(e, city);
              highlightCity(city.code);
            })
            .on("mouseleave", () => {
              hideTooltip();
              unhighlightCity(city.code);
            });

          if (city.connectivity >= 7) {
            svg.append("text")
              .attr("class", "city-label")
              .attr("x", pos[0])
              .attr("y", pos[1] - size - 3)
              .attr("text-anchor", "middle")
              .text(city.code);
          }
        });

        svg.append("circle")
          .attr("class", "origin-marker")
          .attr("cx", originPos[0])
          .attr("cy", originPos[1])
          .attr("r", 7);
      });
    }

    function highlightCity(code) {
      d3.selectAll(`.city-dot[data-code="${code}"]`)
        .attr("stroke-width", 3)
        .attr("r", function() {
          return parseFloat(d3.select(this).attr("r")) * 1.5;
        });
    }

    function unhighlightCity(code) {
      d3.selectAll(`.city-dot[data-code="${code}"]`)
        .attr("stroke-width", 1)
        .attr("r", function() {
          return parseFloat(d3.select(this).attr("r")) / 1.5;
        });
    }

    // ============================================
    // HISTORICAL VIEW
    // ============================================
    let currentEra = 1914;

    function initHistoricalView(land) {
      document.querySelectorAll('.era-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.era-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentEra = parseInt(btn.dataset.era);
          updateHistoricalView(land);
        });
      });

      updateHistoricalView(land);
    }

    function updateHistoricalView(land) {
      const container = document.getElementById('historical-svg');
      const width = container.clientWidth;
      const height = container.clientHeight;

      d3.select("#historical-svg").selectAll("*").remove();

      document.getElementById('era-description').textContent = eraDescriptions[currentEra];

      const projection = d3.geoNaturalEarth1()
        .center([10, 25])
        .scale(width / 5)
        .translate([width / 2, height / 2]);

      const path = d3.geoPath(projection);

      const svg = d3.select("#historical-svg")
        .attr("viewBox", `0 0 ${width} ${height}`);

      svg.append("path")
        .datum(land)
        .attr("class", "land-ghost")
        .attr("d", path);

      const originPos = projection([origin.lng, origin.lat]);

      // Color scale for this era
      const maxTime = d3.max(cities, c => getTravelTime(c, currentEra));
      const eraColorScale = d3.scaleSequential(d3.interpolateInferno)
        .domain([maxTime, 60]);

      cities.forEach(city => {
        const travelTime = getTravelTime(city, currentEra);
        const bear = bearing(origin.lat, origin.lng, city.lat, city.lng);

        // Scale based on era - earlier eras have bigger spread
        const timeScale = currentEra === 1914 ? 0.003 :
                          currentEra === 1950 ? 0.05 :
                          currentEra === 1970 ? 0.15 : 0.25;

        const warpedDistance = travelTime * timeScale;
        const pos = [
          originPos[0] + warpedDistance * Math.sin(bear),
          originPos[1] - warpedDistance * Math.cos(bear)
        ];

        const size = 4 + city.connectivity * 0.4;

        svg.append("circle")
          .attr("class", "city-dot")
          .attr("cx", pos[0])
          .attr("cy", pos[1])
          .attr("r", size)
          .attr("fill", eraColorScale(travelTime))
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .on("mouseenter", (e) => {
            tooltip.select(".tooltip-city").text(`${city.city} (${city.code})`);
            tooltip.select(".tooltip-stats").html(`Travel time in ${currentEra}: ${formatTime(travelTime)}`);
            tooltip
              .style("left", (e.clientX + 15) + "px")
              .style("top", (e.clientY - 10) + "px")
              .classed("visible", true);
          })
          .on("mouseleave", hideTooltip);

        if (city.connectivity >= 8) {
          svg.append("text")
            .attr("class", "city-label")
            .attr("x", pos[0])
            .attr("y", pos[1] - size - 3)
            .attr("text-anchor", "middle")
            .text(city.code);
        }
      });

      svg.append("circle")
        .attr("class", "origin-marker")
        .attr("cx", originPos[0])
        .attr("cy", originPos[1])
        .attr("r", 8);

      svg.append("text")
        .attr("x", originPos[0])
        .attr("y", originPos[1] - 15)
        .attr("text-anchor", "middle")
        .attr("fill", "#ff6b6b")
        .attr("font-weight", "600")
        .attr("font-size", "11px")
        .text("LONDON");

      // Journey times
      const keyRoutes = [
        { code: "JFK", name: "New York" },
        { code: "SYD", name: "Sydney" },
        { code: "HND", name: "Tokyo" },
        { code: "DXB", name: "Dubai" },
      ];

      const journeyContainer = document.getElementById('journey-times');
      journeyContainer.innerHTML = '';

      keyRoutes.forEach(route => {
        const city = cities.find(c => c.code === route.code);
        if (!city) return;
        const time = getTravelTime(city, currentEra);

        const div = document.createElement('div');
        div.className = 'journey';
        div.innerHTML = `
          <div class="journey-route">London → ${route.name}</div>
          <div class="journey-time">${formatTime(time)}</div>
        `;
        journeyContainer.appendChild(div);
      });
    }

    // ============================================
    // INIT
    // ============================================
    async function init() {
      const world = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
      const land = topojson.feature(world, world.objects.land);

      initMorphView(land);
      initSplitView(land);
      initHistoricalView(land);
    }

    init();
  </script>
</body>
</html>
